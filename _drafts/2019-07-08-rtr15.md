---
layout:     post
title:      "Non-Photorealistic Rendering"
subtitle:   "\"《Real-Time Rendering 4th》笔记——第十五章 非真实感渲染\""
date:       2019-01-01
author:     "Ciel"
header-img: "img/post-bg-rtr.jpg"
catalog: true
mathjax: true
tags:
    - Real-Time Rendering
---

# Non-Photorealistic Rendering

> 本章首先详细讨论了实现卡通渲染风格的方法，然后讨论了NPR范围内的其他主题。最后介绍各种线条渲染技术。

非真实感渲染（NPR）也称为风格化渲染。NPR可以用来创建类似于技术说明的图像。只显示那些与特定应用程序的目标相关的细节。比如在修理时只高亮显示发动机的简单线条图。NPR的另一个领域是模拟绘画风格和天然媒介，例如，钢笔和墨水，木炭和水彩。这是一个巨大的领域，适用于各种各样的算法，试图捕捉各种媒体的感觉。考虑到这种宽度，这里主要关注绘制笔画和线条的技术，目标是给出一些用于实时NPR的算法。

![\img\in-post\rtr15\15-1](\img\in-post\rtr15\15-1.jpg)

原书图15.1，应用于咖啡机的各种非真实感渲染风格。

### 1卡通渲染

在NPR中，卡通渲染（cel / toon rendering）吸引了大量注意。因为这种风格具有幻想和童真内涵。最简单的方法是，用实线将不同的纯色区域分隔开来。这种风格流行的原因之一是，通过简化和去除杂乱，可以有放大与呈现相关信息的效果。对于卡通人物，更多观众会认同那些画得简单的风格。

toon渲染风格已经在计算机图形学中使用了几十年，将三维模型与二维cel动画集成在一起。与其它NPR相比，它易于设计，适合计算机自动生成。许多电子游戏都使用它来达到良好的效果。

![\img\in-post\rtr15\15-2](\img\in-post\rtr15\15-2.jpg)

原书图15.2，一个实时渲染NPR游戏例子，Okami(大神)

- 物体的轮廓通常被渲染成黑色，这样可以放大卡通效果。下一节将描述查找和渲染描边的概要。

- 有几种方法来处理卡通材质表面着色。最常见的两种方法是用纯色(非亮色)填充网格区域，或者使用两种色调，分别表示亮区和阴影区。双色调方法，有时称为hard shading，在像素着色器中很容易执行，当法线和光源方向的点积超过某个值时，使用较浅的颜色，如果不超过某个值，则使用较深的色调。当光照更复杂时，另一种方法是量化最终图像本身。也称为色调分离(posterization)，这是一个取一系列连续的值并转换为几个色调的过程，每个色调之间有一个急剧的变化。量化RGB值可能会导致不愉快的色调变化，因为每个单独的通道都以与其他通道不密切相关的方式发生变化。使用HSV、HSL或Y'CbCr等保色空间是更好的选择。使用设计好的一维函数或纹理可以将强度级别重新映射为特定的色调或颜色。纹理也可以使用量化或其他过滤器进行预处理。图15.16显示了另一个具有更多颜色级别的示例。

![\img\in-post\rtr15\15-3](\img\in-post\rtr15\15-3.jpg)

原书图15.3，左边的基本渲染依次应用了实体填充、色调分离和铅笔着色技术。

- [Barla](https://hal.inria.fr/inria-00362888/document/)等人通过使用二维图代替一维阴影纹理来添加依赖于视图的效果。第二个维度是由表面的深度或方向决定的。例如，当物体距离较远或快速移动时，它可以平滑地软化。这个算法，结合了其他各种着色方程和绘制纹理，被用于游戏《军团要塞2》中，以提供卡通和现实风格的混合。toon着色器的变化可以用于其他目的，例如在可视化表面或地形上的特征时，可以放大对比度。

### 2轮廓线(Outline)渲染

用于cel边缘渲染的算法反映了NPR的一些主要主题和技术。下面会提供该领域风格的算法。使用的方法可以粗略地分类为基于表面着色，程序几何，图像处理，几何边缘检测或这些的混合。

- 有几种不同类型的边可以用于toon渲染：

  - 边界(boundary )或边缘是两个三角形不共享的边界，例如纸张的边缘。 实体对象通常没有边界。

  - 折痕(crease)、硬边或特征边是由两个三角形共享的，并且这两个三角形之间的夹角(称为二面角)大于某个预先确定的值。一个好的默认折痕角是60度。折痕边缘可以进一步细分为脊边和谷边。

  - 当共享它的两个三角形在材质上不同或以其他方式引起着色变化时，就会出现材质边缘(material edge )。它也可以是艺术家希望一直展示的边缘，例如，前额的线条，或者是将同一颜色的裤子和衬衫分开的一条线。

  - 轮廓边缘(contour edge )指两个相邻三角形与一些方向向量相比面向不同方向的边缘，通常是来自眼睛的一个方向向量。

  - 剪影边缘(silhouette edge)沿着物体轮廓的轮廓边，即它将目标从图像平面的背景中分离出来。

  这种分类基于文献中常用用法，但也有一些变化，我们所说的折痕和材料边缘有时在其他地方称为边界边缘(boundary edges )。

![\img\in-post\rtr15\15-4](\img\in-post\rtr15\15-4.jpg)

原书图15.4，顶部打开的盒子，正面有条纹。显示边界(B,boundary)、折痕(C,crease)、材质(M,material)和轮廓(S,silhouette)。根据所给的定义，没有一条边界(boundary)被认为是轮廓边(silhouette)，因为这些边只有一个邻接的多边形。

- 我们在这里区分contour 和silhouette 。两者都是边缘，表面的一部分面向观察者，另一部分面向外。Silhouette是contour的子集，Silhouette将物体与另一个物体或背景分开。例如，在头部的侧视图中，耳朵形成轮廓边缘(contour)，即使它们出现在头部的轮廓(silhouette)中。在一些早期文献中，contour边缘被称为silhouettes，但通常意味着完整的轮廓边缘类别。 此外，轮廓边(contour edges)不应与地形图上使用的轮廓线(contour lines)混淆。
- 注意，边界边缘(boundary edges)与轮廓线(contour)或剪影边缘(silhouette)不相同。轮廓和轮廓边缘由视图方向决定，而边界边缘与视图无关。暗示轮廓(Suggestive contours)由几乎是原始视点轮廓的位置形成。 它们提供额外的边缘，有助于传达物体的形状。虽然这里的重点主要是检测和绘制轮廓边缘，但已经为其他类型的笔画做了大量工作。主要是关注多边形模型的这种边。还有讨论寻找由细分曲面或其他高阶定义组成的模型轮廓的方法，在原书参考书目中。

![\img\in-post\rtr15\15-5](\img\in-post\rtr15\15-5.jpg)

原书15.5，从左到右:silhouette，contour，contour与suggestive contour edges。

#### 2.1着色法向轮廓边缘

- 可以使用法线与视线的点积来给出轮廓边缘。如果这个值接近于零，那么这个表面几乎与眼睛平行，所以很可能接近轮廓边缘。将这些区域涂成黑色，随着点积的增加，这些区域逐渐变成白色。在可编程着色器之前，该算法是使用带有黑环的球面环境映射实现的，或者将mipmap金字塔纹理的最顶层涂成黑色。现在这种类型的着色是直接在像素着色器中实现的，当屏幕法线垂直于视图方向时，将其变为黑色。

![\img\in-post\rtr15\15-6](\img\in-post\rtr15\15-6.jpg)

原书图15.6，当阴影法线垂直于视图方向时，通过使曲面变暗来修剪轮廓边缘。通过加大衰减角度，可以显示更粗的边缘。

- 这种着色在某种意义上与边缘光相反（其中边缘光照亮了物体的轮廓）;在这里，场景从眼睛的位置被照亮，并且下降被夸大，使边缘变暗。它也可以被认为是图像处理中的阈值滤波器，当图像的表面低于一定的强度时，图像就会被转换成黑色，否则就会被转换成白色。

- 这种方法的一个特点或缺点是，轮廓线是根据曲面的曲率绘制的，轮廓线宽度是可变的。这种方法适用于没有折痕边缘的曲面模型，例如，轮廓线附近的区域通常有法线几乎垂直于视图方向的像素。该算法在立方体这样的模型上会失败，因为折痕边缘附近的表面没有这个特性。即使在曲面上，它也会看起来很糟糕，因为当物体距离较远时，在轮廓边缘附近采样的一些法线可能并不垂直。尽管如此，Goodwin等人指出这一基本概念仍然具有作为视觉提示的有效性，并讨论了如何结合光照、曲率和距离来确定笔画厚度。

#### 2.2程序几何剪影

- 最早的实时轮廓边缘绘制技术之一是由Rossignac和van Emmerik提出的，后来由Raskar和Cohen改进。一般的想法是正常渲染正面，然后渲染背面，使其轮廓边缘可见。绘制这些背景的方法有很多种，每种方法都有自己的优缺点。每种方法的第一步都是绘制正面。然后打开正面剔除frontface culling，关闭背面剔除backface culling，这样就只渲染背面。

- 渲染轮廓的一种方法是只绘制背景的边缘(而不是面)。使用偏置或其他技术(第15.4节)确保这些线中的一些只是在正面绘制。这样，只有正面和背面相交的边缘才可见。

- 使这些线条更宽的一种方法是将背面本身渲染成黑色，再次向前倾斜。Raskar和Cohen给出了几种偏置方法，比如用固定的量平移，或者用补偿深度非线性量平移，或者使用深度-斜率偏置调用，比如OpenGL的glPolygonOffset。Lengyel讨论了如何通过修改透视图矩阵来提供更好的深度控制。所有这些方法的一个问题是，它们没有创建宽度相同的线。要做到这一点，向前移动的量不仅取决于背面，还取决于相邻的正面。如下图，背面的斜率可以用来使多边形向前偏置，但是线条的厚度也将取决于正面的角度。

![\img\in-post\rtr15\15-7](\img\in-post\rtr15\15-7.jpg)

原书图15.7，剪影的z偏差方法，通过向后平移背面来完成。如果正面处于不同的角度，如右图所示，可以看到不同程度的背面。

- Raskar和Cohen解决了这个邻居依赖问题，他们将每个背向三角形的边沿加厚，使之达到一致粗细的宽度。也就是说，三角形的斜率和与观察者的距离决定了三角形被扩展了多少。一种方法是将每个三角形的三个顶点沿其平面向外展开。绘制三角形的一个更安全的方法是将三角形的每条边向外移动并连接这些边。这样做可以避免顶点在远离原始三角形的地方。注意，此方法不需要任何偏置，因为后面板扩展到前面板的边缘之外。这种增大技术更加可控和一致，并已成功地应用于电子游戏中，如《波斯王子》(Prince of Persia)和《非洲武士》(Afro Samurai)。

![\img\in-post\rtr15\15-8](\img\in-post\rtr15\15-8.jpg)

原书图15.8，三角形增大(fattening)。左边，一个背面三角形沿着它的平面展开。每条边在世界空间中移动不同的量，使所得到的边在屏幕空间中具有相同的厚度。对于薄三角形，随着一个角被拉长，这种技术就会失败。在右边，三角形边被展开并连接，形成斜接角，以避免这个问题。

![\img\in-post\rtr15\15-9](\img\in-post\rtr15\15-9.jpg)

原书图15.9，轮廓线背面绘制分别使用粗线，z偏置，和扩大三角形算法。由于小特征的偏置问题，背面边缘技术使得线与非均匀线之间的连接很差。z-bias技术由于依赖于正面的角度，使得边缘宽度不均匀。

- 在刚刚给出的方法中，背面三角形沿原平面展开。另一种方法是通过沿着共享顶点法线移动它们的顶点向外移动，移动量与它们到眼睛的z距离成比例。这被称为shell或halo方法，因为移位的后面对原始对象形成一个壳(shell)。沿着法线向外移动顶点是顶点着色器的一个完美任务。这种类型的展开有时称为shell映射。该方法实现简单、快速、鲁棒，性能稳定。

![\img\in-post\rtr15\15-10](\img\in-post\rtr15\15-10.jpg)

原书图15.10，三角形壳层技术通过沿着顶点法线移动曲面来创建第二个曲面。

![\img\in-post\rtr15\15-11](\img\in-post\rtr15\15-11.jpg)

原书图15.11，一个实时的卡通风格渲染例子，出自《Cel Damage》。使用背面的外壳扩展，形成轮廓边缘，以及显式的折痕边缘绘制。

- 这种shell技术有几个潜在的缺陷。想象一下正对着一个立方体，这样只有一个面是可见的。形成等高线边缘的四个背板，每个背板都将沿着对应的正方体面方向移动，从而留下间隙。这是因为，虽然每个角上都有一个顶点，但每个面都有一个不同的法线顶点。展开的立方体并没有真正形成一个壳层，因为每个角顶点都在向不同的方向展开。一种解决方案是强迫相同位置的顶点共享一个新的平均顶点法线。另一种技术是在折痕处创建简并几何，然后将折痕展开成三角形。Lira等使用一个额外的阈值纹理来控制每个顶点移动了多少。

- shell和fattening技术浪费了一些填充物，因为所有的背面都是通过管道输送的。所有这些技术的其他限制是，对边缘外观几乎没有控制，而且根据使用的透明算法，要正确呈现半透明的表面非常困难。

- 这整类几何技术的一个有价值的特征是在渲染过程中不需要连接信息或边缘列表。 每个三角形独立于其余三角形进行处理，因此这些技术适用于GPU实现。

- 这类算法只渲染轮廓边缘。Raskar给出了一个在变形模型上绘制脊折痕边缘的巧妙解决方案，而无需创建和访问边缘连接数据结构。其思想是沿着呈现的三角形的每条边生成一个额外的多边形。这些边多边形被用户定义的临界二面角从三角形的平面上弯曲，这个二面角决定了什么时候折痕应该是可见的。如果在任何给定时刻，相邻的两个三角形处于大于这个折痕角的位置，则边缘将是可见的，否则它们将被三角形隐藏。谷边(Valley edges)可以用类似的技术，但需要一个模板和多个通道。

![\img\in-post\rtr15\15-12](\img\in-post\rtr15\15-12.jpg)

原书图15.12，两个三角形边连在一起的侧视图，每个三角形都有一个小“鳍”。当这两个三角形沿着边缘弯曲时，它们的鳍向可见的方向移动。右图中鳍露出来了，涂成黑色，这些看起来像一个山脊边缘。使用环境颜色渲染场景或使用对象同质值可以用于检测材质、边界和真实轮廓边缘。

#### 2.3图像处理边缘检测

上一节中的算法有时被分类为基于图像的算法，因为屏幕分辨率决定了它们的执行方式。另一种类型的算法更直接地基于图像，因为它完全是对存储在image buffers中的数据进行操作，而不修改(甚至不直接知道)场景中的几何形状。

- 斋藤和高桥介绍了G-bffuer概念，也用于延迟着色(第20.1节)。Decaudin扩展使用G -buffer来执行toon呈现。其基本思想很简单:NPR可以通过对各种信息缓冲区执行图像处理算法来实现。通过在邻近的z-bffuer值中寻找不连续点，可以找到许多轮廓边缘位置。相邻曲面不连续的法线值常常是轮廓线和边界边缘位置。以环境颜色或使用对象标识值渲染场景可用于检测材质，边界和真实轮廓边。

- 检测和绘制这些边缘由两部分组成：首先，渲染场景的几何形状，使用像素着色器保存不同渲染目标所需的深度、法线、对象id或其他数据。然后按照第12.1节中描述的类似方法执行后处理传递。后处理将每个像素周围的邻域作为样本传递，并根据这些样本输出结果。例如，假设场景中的每个对象都有一个惟一的标识值。在每个像素处，我们可以对这个ID进行采样，并将其与测试像素角处的四个相邻像素ID值进行比较。如果任何ID与测试像素的ID不同，则输出黑色，否则输出白色。采样所有8个相邻像素更简单，但采样成本更高。这种简单的测试可以用来绘制大多数物体的边界和轮廓线(剪影轮廓silhouettes)。材质id可以用来查找材质边缘。

- 轮廓边缘可以通过在法线和深度缓冲上使用不同的滤波器来发现。例如，如果相邻像素之间的深度差异大于某个阈值，则很可能存在轮廓边缘，因此将像素变为黑色。我们需要的不是简单地判断相邻像素是否与样本匹配，而是更精细的边缘检测操作。这里不讨论各种边缘检测滤波器的优缺点，例如Roberts cross、Sobel和Scharr，因为图像处理文献对这些进行了广泛的讨论。注意，法线缓冲区也可以检测折痕边缘，因为法线之间的较大差异可以表示轮廓或折痕边缘。Thibault和Cavanaugh讨论了他们如何使用深度缓冲在《Borderlands》中。他们还修改了Sobel滤波器，使其创建单像素宽的轮廓和深度计算，以提高精度。如下图，也可以沿着另一个方向，只在阴影周围添加轮廓线，忽略相邻深度更大的边缘。

![\img\in-post\rtr15\15-13](\img\in-post\rtr15\15-13.jpg)

原书图15.13，《Borderlands》中修改了的Sobel边缘检测。最终发布的版本(这里没有显示)通过为前景中的草遮去边缘，进一步改进了外观。

- 膨胀算子(dilation operator)是一种形态学算子，用于对检测到的边缘进行增厚。生成边缘图像后，应用一个单独的通道。对每个像素，像素的值及其周围的值在一定半径内进行检查。找到的最暗像素值作为输出返回。这样，一条细细的黑线就会被搜索区域的直径加粗。可以将多个遍历应用于进一步加粗线，其代价是每个遍历所需的样本要少得多，从而抵消了额外遍历的成本。不同的结果可以有不同的厚度，例如，轮廓边缘可以比其他轮廓边缘更厚。相关的腐蚀算子可用于减薄线或其他效果。

![\img\in-post\rtr15\15-14](\img\in-post\rtr15\15-14.jpg)

原书图15.14，法线贴图(左上角)和深度贴图(上中)对其值进行Sobel边缘检测，结果分别显示在左下角和中下。右上角的图像是使用膨胀增厚的。右下角的最终渲染是通过使用Gooch着色对图像进行着色并在边缘进行合成来完成的。

- 这种算法有几个优点。它处理所有类型的表面，平面或曲面，不同于大多数其他技术。网格不需要连接，甚至不需要一致，因为该方法是基于图像的。

- 这种技术的缺陷相对较少。对于接近边缘的曲面，z-depth比较滤波器会错误地检测出曲面上的轮廓边缘像素。z-depth比较的另一个问题是，如果误差很小，那么轮廓边缘就会被忽略。例如，桌子上的一张纸通常会缺边。同样，法线贴图过滤器也会漏掉这张纸的边缘，因为法线是相同的。一张折叠起来的纸会在边缘重叠的地方产生无法检测的边缘。生成的线条显示了阶梯状锯齿，但是第5.4.2节中描述的各种形态抗锯齿技术可以很好地处理这种高对比度输出，以及色调分离等技术，以提高边缘质量。

- 检测也可能以相反的方式失败，在不应该存在的地方创建边缘。例如，想象一朵玫瑰的茎，一个薄薄的圆柱体。近距离观察，我们样本像素附近的茎法线变化不大，因此没有检测到边缘。当我们远离玫瑰时，法线会随着像素的不同而变化得更快，直到某一时刻，由于这些差异，边缘附近可能会发生错误的边缘检测。类似的问题也会发生在从深度图中检测边缘时，透视图对深度的影响是需要补偿的额外因素。Decaudin提供了一种改进的方法，通过处理法线和深度映射的梯度来查找更改，而不仅仅是值本身。决定不同的像素差异如何转化为颜色变化是一个经常需要针对内容进行调整的过程，如下图：

![\img\in-post\rtr15\15-15](\img\in-post\rtr15\15-15.jpg)

原书图15.15，各种边缘的方法。特征边如皱纹，是纹理本身的一部分，由艺术家事先添加。人物的剪影轮廓(silhouette)是通过背面挤压产生的。轮廓边缘采用图像处理边缘检测方法生成，具有不同的权值。左边的图像产生的权重太少，所以这些边缘是微弱的。中间显示了轮廓(outlines)，特别是鼻子和嘴唇的轮廓边缘(contour edges)。右边显示使用太大权重的结果。

- 一旦生成笔画，就可以按需要执行进一步的图像处理。由于笔触可以在单独的缓冲区中创建，所以可以单独修改笔触，然后在表面上合成笔触。例如，可以使用噪声函数分别磨损和摆动线条和表面，在两者之间创建小的间隙，并给出一个手绘的外观。纸张的高度可以用来影响渲染效果，比如在凹凸不平的顶部沉积木炭，或者在凹处沉积水彩颜料。

![\img\in-post\rtr15\15-16](\img\in-post\rtr15\15-16.jpg)

原书图15.16，左边的鱼模型在右边使用边缘检测、色调分离、噪声干扰、模糊和混合在纸上呈现。

- 在这里集中于使用几何或其他非图形数据(如法线、深度和id)检测边缘。这种边缘检测技术也可以应用到颜色缓冲区。其中一种方法称为高斯差分法(difference of Gaussians,DoG)，该方法使用两个差分高斯滤波器对图像进行两次处理，其中一个滤波器与另一个滤波器相减。这种边缘检测方法可以为NPR生成特别令人满意的结果，用于生成各种艺术风格的图像，如铅笔和彩色粉笔。

- 图像后处理操作在许多NPR技术中扮演重要角色，这些技术模拟了水彩和丙烯酸颜料等艺术媒体。在这一领域对于交互式应用程序来说，最大的挑战是尝试用最少的纹理样本做最多的工作。双边，均值偏移，和Kuwahara过滤器可以用于GPU上保存边缘和平滑区域，以显示图像绘制。Kyprianidis等人对该领域的图像处理效果进行了全面的回顾和分类。Montesdeoca等人将许多简单的技术组合成以交互式速率运行的水彩效果。

![\img\in-post\rtr15\15-17](\img\in-post\rtr15\15-17.jpg)

原书图15.17，左边是一个标准的真实渲染。在右边，水彩画风格通过均值变换颜色匹配软化纹理，增加对比度和饱和度等技术实现。

#### 2.4几何轮廓边缘检测

目前给出的方法存在一个问题，即边缘的风格化最多是有限的。我们不能轻易地使线条看起来破碎，更不用说看起来像手绘或笔触。对于这种操作，我们需要找到轮廓边并直接渲染它们。具有单独的独立边缘实体可以创建其他效果，例如当网格在震动中冻结时使轮廓突然跳跃。

- 轮廓边缘(contour edge)是两个相邻三角形中的一个面向观察者，另一个面向远处。$(n_0\cdot v)(n_1\cdot v)<0$，其中n0和n1为两个三角形法线，v为从眼睛到边缘的视图方向。要使该测试正确工作，表面必须始终保持定向(第16.3节)。

- 在模型中寻找轮廓边的暴力法是遍历边缘列表并执行此测试。Lander指出，一个有价值的优化是识别和忽略平面多边形内的边。也就是说，给定一个连通三角形网格，如果一条边的两个相邻三角形位于同一平面，那么这条边就不可能是轮廓边。此外，如果模型定义了一个实体，凹边永远不能是轮廓边。Buchanan和Sousa通过重用每个面的点积测试，避免了对每个边缘做单独的点积测试。

- 从头开始检测每一帧的轮廓边缘可能是昂贵的。如果相机视图和对象在帧与帧之间移动得很少，那么可以合理地假设之前帧的轮廓边缘仍然是有效的轮廓边缘。Aila和Miettinen将有效距离与每条边关联起来。这个距离是指观察者可以移动多远而轮廓边缘仍然保持它的状态。在任何实体模型中，每个单独的轮廓线总是由一条闭合的曲线组成，称为轮廓线回路(silhouette loop)，或者更确切地说，是contour loop。对于对象边界内的轮廓，循环的某些部分可能会被模糊。甚至实际的轮廓也可能由几个环组成，环的一部分在轮廓内或隐藏在其他表面。因此，每个顶点必须有偶数条轮廓边。参见图15.18。请注意，当沿着网格边缘时，循环在三维空间中经常是锯齿状的，z-depth的变化非常明显。如果需要形成光滑曲线的边缘，例如根据距离改变厚度，此外还可以对三角形的法线进行插值，以逼近三角形内的真实轮廓边缘

![\img\in-post\rtr15\15-18](\img\in-post\rtr15\15-18.jpg)

原书图15.18，轮廓循环。左边是相机对模型的视图。中间的蓝色部分显示了背对相机的三角形。右边是脸部某一区域的特写。注意它的复杂性，以及一些轮廓线是如何隐藏在鼻子后面的。

- 从一帧到另一帧跟踪循环位置比从头创建循环要快。Markosian等人从一组循环开始，并使用随机搜索算法在摄像机移动时更新这组循环。当模型改变方向时，还会创建和销毁轮廓回路。Kalnins等人注意到，当两个循环合并时，需要采取纠正措施，否则从一个帧到下一个帧的明显跳跃将是可见的。他们使用像素搜索和“投票”算法来保持帧与帧之间的轮廓一致性。

- 这种技术可以显著提高性能，但可能不精确 。线性方法是精确的，但是很昂贵。分层方法，使用相机访问轮廓边缘结合速度和精度。对于非动画模型的正投影视图，Gooch等人使用高斯图的层次结构来确定轮廓边缘。Sander等人使用正常锥体的n-ary树（第19.3节）。Hertzmann和Zorin使用模型的双空间表示，这允许他们在模型的边缘强加层次结构。

- 所有这些显式边缘检测方法都是CPU密集型的，缓存一致性较差，因为形成轮廓的边缘分散在边缘列表中。为了避免这些成本，顶点着色器可以用来检测和渲染轮廓边缘。其思想是将模型的每条边沿着管线发送，两个三角形形成一个退化的四边形，每个顶点上都有两个相邻的三角形法线。当发现边缘是轮廓的一部分时，移动四边形的点，使其不再退化(可见)。然后画出这个薄的四边形鳍。该技术基于与为阴影创建轮廓边缘相同的思想(第7.3节)。如果几何着色器是管道的一部分，这些额外的鳍四边形不需要存储，但可以动态生成。一个简单的实现将在鳍之间留下裂缝和缺口，可以通过修改鳍的形状来纠正。

#### 2.5隐藏线消除

- 一旦找到轮廓线，就绘制线条。显式找到边缘的一个好处是，您可以将这些样式化为钢笔笔触、颜料笔触或任何您想要的其他媒介。笔触可以是基本的线条、纹理(第13.6.4节)、一组基本类型，或者您想尝试的任何其他类型。

- 尝试使用几何边的另一个复杂之处是，并非所有这些边都是可见的。绘制表面来建立z缓冲区可以掩盖隐藏的几何边缘，这对于简单的样式(如虚线)可能足够了。Cole和Finkelstein通过沿着线本身的脊柱采样z深度来扩展这个表示线的四边形。但是，使用这些方法，沿线的每个点都是独立渲染的，因此事先不知道明确定义的起点和终点位置。对于轮廓循环或线段用于定义笔划或其他连续对象的其他边缘，我们需要知道每个笔划何时首次出现，何时消失。确定每个线段的可见性称为隐线呈现(hidden line rendering)，其中一组线段用于处理可见性，返回一组更小的线段(可能是剪切的)。

- Northrup和Markosian通过渲染所有对象的三角形和轮廓边，并为每个对象分配不同的标识号来解决这个问题。读取此ID缓冲区，并从中确定可见的轮廓边缘。然后检查这些可见段是否有重叠，并将它们连接在一起，形成平滑的描边路径。如果屏幕上的线段很短，这种方法可以工作，但是它不包括线段本身的剪切。然后沿着这些重建路径呈现风格化的笔画。笔触本身可以通过许多不同的方式进行程式化，包括锥形、耀斑、摆动、超调和渐退的效果，以及深度和距离提示(taper, fare, wiggle, overshoot, and fading, as well as depth and distance cues)。

![\img\in-post\rtr15\15-19](\img\in-post\rtr15\15-19.jpg)

原书图15.19，使用Northrup和Markosian的混合技术制作的图像。轮廓边缘被发现，被构建成链，并呈现为笔画。

- Cole和Finkelstein提出了一种边缘集的可见性计算方法。他们将每个线段存储为两个世界空间坐标值。一系列的传递在整个段的集合上运行一个像素着色器，裁剪并确定每个段的像素长度，然后为每个潜在的像素位置创建一个图集并确定可见性，然后使用这个图集创建可见的笔画。这个过程虽然复杂，但在GPU上相对较快，并且提供了一组已知开始和结束位置的可见笔画。

- 风格化通常包括将一个或多个预制纹理应用到线四边形。Rougier讨论了另一种方法，程序化呈现虚线模式。每个线段访问存储所需的所有虚线图案的纹理。每个模式都被编码为一组命令，指定虚线模式以及使用的端点和连接类型。 使用四边形的纹理坐标，每个模式控制着色器进行的一系列测试，以确定线条覆盖四边形中每个点的像素的多少。

- 确定轮廓边缘，将它们连接成链，然后确定每条链的可见性以形成笔划是难以完全并行化的。在产生高质量线条样式时的另一个问题是，对于下一帧改变长度或第一次出现，将再次绘制每个笔划。Benard等人对绘制方法进行了研究，这些方法为沿边缘和表面上的图案提供了时间一致性。这不是一个已经解决的问题，涉及到计算，所以研究还在继续。

### 3画笔表面样式

虽然toon渲染是一种流行样式，但还有无数其他样式可以应用于表面。效果可以从修改真实纹理到让算法逐帧生成几何装饰。本节将简要介绍与实时渲染相关的技术。

- Lake等人讨论了使用漫反射着色项来选择一个表面使用的纹理。当漫反射项变暗时，使用带有较暗效果的纹理。纹理被应用到屏幕空间坐标，给一个手绘的外观。为了进一步增强草图的外观，在屏幕空间的所有表面都应用了纸纹理。这种算法的一个主要问题是淋浴门效应，在动画中，对象看起来像通过有图案的玻璃看到的。物体给人的感觉是它们在纹理中游动。Breslav等人通过确定哪些图像变换最适合某些基础模型位置的移动来维持纹理的二维外观。 这可以保持与填充图案的基于屏幕性质的连接，同时提供与对象的更强连接。

![\img\in-post\rtr15\15-20](\img\in-post\rtr15\15-20.jpg)

原书图15.20，使用纹理调色板、纸张纹理和轮廓边缘渲染生成的图像。

- 一个显而易见的解决方案是直接将纹理应用到表面。问题是基于描边的纹理需要保持一个相对统一的描边厚度和密度，才能看起来令人信服。如果纹理被放大，笔画看起来太粗;如果将其缩小，笔画要么模糊，要么很细且有噪声(取决于是否使用mipmapping)。Praun等人提出了一种实时生成描边纹理mipmap的方法，并将其平滑地应用于表面。这样做可以在对象距离变化时保持屏幕上的笔画密度。第一步是形成要使用的纹理，称为色调艺术映射(tonal art maps,TAMs)。这是通过在mipmap级别中绘制笔画来实现的。参见图15.21。Klein等人在他们的“art map”中使用了一个相关的想法来维护NPR纹理的笔画大小。有了这些纹理，模型就可以通过在每个顶点所需的色调之间插入来呈现。这种技术产生的图像具有手绘的感觉。见图15.22。

![\img\in-post\rtr15\15-21](\img\in-post\rtr15\15-21.jpg)

原书图15.21，色调艺术图(TAMs)。笔画被绘制到mipmap级别。每个mipmap级别包含从纹理到左边和上面的所有笔画。这样，mip层和相邻纹理之间的插值就是平滑的。

![\img\in-post\rtr15\15-22](\img\in-post\rtr15\15-22.jpg)

原书图15.22，使用色调艺术图(TAMs)渲染的两个模型。样条显示了用于渲染每个纹理的重叠纹理模式。

- Webb等人对TAMs提出了两种扩展，一种使用体积纹理(允许使用颜色)，另一种使用阈值方案(改进了抗锯齿)，从而得到更好的结果。Nuebel给出了一种执行木炭渲染的相关方法。他使用了噪音纹理，沿一个轴从按到亮。强度值沿着这个轴访问纹理。Lee等使用TAMs和其他技术生成铅笔绘制的令人印象深刻的图像。为了得到一个草图效果，边缘可以抖动，也可以超过它们原来的位置，如图15.1所示的右上和中下图像。

- Girshick等人讨论了沿着曲面上的主曲线方向线绘制笔画。也就是说，从曲面上任意给定的点出发，有一个主方向切向量指向最大曲率的方向。第二个主方向是垂直于第一个向量的切向量，给出了曲面最小弯曲的方向。这些方向线在感知曲面时很重要。它们还有一个优点，即只需要为静态模型生成一次，因为这样的笔画与光照和着色无关。Hertzmann和Zorin讨论了如何清理和理顺主要方向。大量的研究和开发已经探索了使用这些方向和其他数据将纹理应用于任意表面，驱动模拟动画，以及其他应用程序。以Vaxman等人的报告为起点。

- 嫁接的思想是几何或贴花纹理可以根据需求添加到一个表面产生特殊的效果。它们可以由所需的细节水平、表面对眼睛的方向或其他因素控制。这些也可以用来模拟笔或笔触。图15.23显示了一个示例。几何嫁接是一种程序化建模的形式。

![\img\in-post\rtr15\15-23](\img\in-post\rtr15\15-23.jpg)

原书图15.23，斯坦福兔两种不同的嫁接方式。

### 4线

绘制简单的实体“硬”线通常被认为是相对无趣的。然而，在CAD等领域，它们对于查看底层模型切面和识别对象的形状非常重要。它们在突出显示选中的对象和技术说明等领域也很有用。此外，所涉及的一些技术也适用于其他问题。

#### 4.1三角形边缘渲染

- 正确绘制填充三角形顶部的边比它最初出现时更加困难。如果一条线与一个三角形的位置完全相同，我们如何确保这条线总是呈现在前面?一个简单的解决方案是渲染线时带有固定偏差。也就是说，每一行都被渲染得比实际距离更近一些，这样它就会在表面上。如果固定偏差太大，应该隐藏的边缘部分就会出现，破坏效果。如果偏置过小，几乎是边缘的三角形表面可以隐藏部分或全部边缘。如第15.2.2节所述，可以使用诸如OpenGL的glPolygonOffset之类的API调用根据直线的斜率向后移动直线下方的表面。这种方法工作得相当好，但并不完美。

- Brentzen等人提出了一种可以很好地映射到GPU的方法。他们使用像素着色器，使用三角形的重心坐标来确定到最近边缘的距离。如果像素靠近边缘，则用边缘颜色绘制。边缘厚度可以是任何想要的值，也可以由距离或常数来反映。主要缺点是轮廓线的绘制只有内线的一半厚，因为每个三角形只绘制每条线厚度的一半。实际上，这种不匹配通常并不明显。

![\img\in-post\rtr15\15-24](\img\in-post\rtr15\15-24.jpg)

原书图15.24，像素着色器生成线条。左边是抗锯齿的单像素宽度边缘;右边是带晕圈的可变厚度线。

- Celes和Abraham对这一观点进行了扩展和简化，并对前人的工作进行了全面的总结。他们的想法是对每个三角形边缘使用一维纹理坐标集，对定义边缘的两个顶点使用1.0，对其他顶点使用0.0。他们利用纹理映射和mip链来提供一个等宽的边缘。这种方法易于编写代码，并提供了一些有用的控件。例如，可以设置最大密度，这样密集的网格就不会完全充满边缘，从而变成纯色。

#### 4.2渲染被遮挡的线

- 在普通线框图中，没有绘制表面，模型的所有边都是可见的。为了避免绘制被表面隐藏的线，将所有填充的三角形只绘制到z缓冲区中，然后正常地绘制边缘。如果在绘制所有线条之前不能绘制所有的表面，一个稍微昂贵的解决方案是使用与背景匹配的纯色绘制表面。

- 线条也可以绘制为部分模糊，而不是完全隐藏。例如，隐藏的线可以显示为浅灰色，而不是完全不绘制。这可以通过适当地设置z缓冲区的状态来实现。像以前一样绘制，然后反转z缓冲区，以便只绘制超出当前像素z深度的线。还要关闭z缓冲修改，这样这些绘制的线不会改变任何深度值。以模糊的样式再次绘制线条。然后只绘制隐藏的线。对于线条的程序化版本，可以使用完整的隐藏线删除过程。

#### 4.3光晕

- 当两条线交叉时，常见的惯例是擦除较远线的一部分，使得排序明显。 这可以通过每条线画两次相对容易地完成，一次用光晕。该方法通过在背景颜色上绘制来消除重叠。首先，将所有线绘制到z缓冲区，将每条线表示为表示晕的粗四边形。一个几何着色器可以帮助创建这样的四边形。然后，用正常的颜色画出每条线。z缓冲区绘制的区域将隐藏在它们后面绘制的线。必须使用偏置或其他方法来确保每个细黑线位于粗z缓冲区四边形之上。

- 在顶点相交的线可能被相互竞争的光晕部分隐藏。缩短创建晕的四边形可能会有所帮助，但也可能导致其他工件。Brentzen等人的线条渲染技术也可以用于卤化。参见图15.24。每个三角形都会产生光晕，所以没有干扰问题。另一种方法是使用图像后处理(第15.2.3节)来检测和绘制晕。图15.25显示了这里讨论的一些不同的线渲染方法的结果。

![\img\in-post\rtr15\15-25](\img\in-post\rtr15\15-25.jpg)

原书图15.25，四种线渲染风格。从左到右:线框，隐藏线，遮挡线，光晕线。

### 5文本渲染

与许多其他对象不同的是，单个像素的改变可以产生显著的差异，比如将“l”变成“1”。本节总结用于文本渲染的主要算法方法。

- 眼睛对亮度的差别比对颜色的差别更敏感。这个想法的一个应用是微软的ClearType技术，它是液晶显示器(LCD)的一个特性。液晶显示器上的每个像素由三个垂直的彩色矩形组成，分别是红色、绿色和蓝色。不管这些亚像素矩形的颜色如何，这种填充提供的水平分辨率是像素的三倍。使用不同的阴影填充不同的子像素，因此这种技术有时被称为亚像素渲染(subpixel rendering)。眼睛将这些颜色混合在一起，红色和蓝色的条纹变得无法检测。

![\img\in-post\rtr15\15-26](\img\in-post\rtr15\15-26.jpg)

原书图15.26，放大灰度抗锯齿和亚像素抗锯齿的同一个单词。当彩色像素显示在LCD屏幕上时，组成像素的相应彩色垂直亚像素矩形被点亮。这样做提供了额外的水平空间分辨率。

- 字体中的字符称为字形(glyphs)，通常由一系列线段和二次或三次贝塞尔曲线来描述，有关示例参见图17.9。所有的字体渲染系统的工作是确定一个字形如何影响它重叠的像素。FreeType和Anti-Grain Geometry等库通过为每个字形生成一个小纹理并根据需要重用它们来工作。每种字体大小和重点(即斜体或粗体)都有不同的纹理。

- 这些系统假设每个纹理都是像素对齐的，每个像素对应一个纹素。当文本应用于三维表面时，这些假设可能不再成立。使用带有一组符号的纹理是一种简单而流行的方法，但是有一些潜在的缺点。应用程序仍然可以将文本对齐到查看器，但是缩放和旋转将打破每个像素只有一个纹素的假设。即使屏幕对齐，也可能不考虑字体微调(font hinting)。微调(hinting)是调整字形轮廓以匹配像素单元的过程。例如，一个宽度为一纹素的“I”的垂直竖条最好渲染为覆盖一列像素，而不是覆盖相邻两列的一半。所有这些因素意味着光栅纹理有显示模糊或混叠问题。Rougier全面介绍了与文本再生算法相关的问题，并展示了如何在基于opengl的符号渲染系统中使用FreeType微调。

![\img\in-post\rtr15\15-27](\img\in-post\rtr15\15-27.jpg)

原书图15.27，Verdana字体渲染无微调(顶部)和微调(底部)。

- Pathfinder库是最近出现的，它使用GPU生成字形。它具有较低的设置时间和最小的内存使用，并优于其他基于cpu的引擎。它使用细分和计算着色器来生成和总结每个像素上的曲线，在性能较差的gpu上使用回退的几何着色器和OpenCL。与FreeType一样，这些符号也被缓存和重用。其高质量的抗锯齿，结合使用高密度显示器，使微调几乎被淘汰。

- Green介绍了这样一个系统：将文本应用到不同大小和方向的任意表面上，无需复杂的GPU支持，同时仍然可以提供合理的抗锯齿。该算法采用了Frisken等人引入的采样距离场(sampled distance field)数据结构。每个纹素保存符号到符号最近边缘的距离。距离字段试图在纹理描述中编码每个符号的精确边界。然后，双线性插值给出了每个样本处字母的阿尔法覆盖近似值。尖锐的角可以通过双线性插值得到平滑，但可以通过在四个独立的通道中编码更多的距离值来保持。此方法的一个限制是，创建这些带符号的距离纹理非常耗时，因此需要预先计算并存储它们。尽管如此，许多字体呈现库都基于这种技术，并且它很好地适应移动设备。Reshetov和Luebke总结了这方面的工作，并给出了他们自己的方案，基于在放大过程中调整样本的纹理坐标。

![\img\in-post\rtr15\15-28](\img\in-post\rtr15\15-28.jpg)

原书图15.28，矢量纹理。左边，字母“g”显示在其距离场表示中。右边，“no trespassing”标志由距离场渲染。通过将特定距离范围映射到轮廓颜色来添加文本周围的轮廓。

- 即使不考虑缩放和旋转，使用汉字的字体也可能需要数千个或更多的字形。高质量的大字符需要更大的纹理。如果从一个角度观察字形，可能需要纹理的各向异性。直接从边缘和曲线描述绘制字形可以避免对任意大纹理的需要，也可以避免来自采样网格的伪影。Loop-Blinn方法使用像素着色器直接计算Bezier曲线，在第17.1.2节中讨论。这种技术需要一个细分步骤，当在加载时完成可能消耗昂贵。Dobbie通过为每个字符的边界框绘制矩形，并在一次遍历中计算所有字形轮廓，从而避免了这个问题。Lengyel提出了一个健壮的评估器，用于评估一个点是否在一个符号中，这对于避免伪影至关重要，并讨论了评估优化和效果，如发光、阴影和多种颜色(例如表情符号)。

### 扩展阅读和资料










