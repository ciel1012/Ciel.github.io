---
layout:     post
title:      "Shadows"
subtitle:   "\"《Real-Time Rendering 4th》笔记——第七章 阴影\""
date:       2019-12-19
author:     "Ciel"
header-img: "img/post-bg-rtr.jpg"
catalog: true
mathjax: true
tags:
    - Real-Time Rendering
---

# Shadows

> 本章主要介绍计算阴影的基本原理，并介绍最重要和最流行的实时算法，以及不太流行但是体现了重要原则的方法。

本章使用的术语如图7.1所示，其中occluders将阴影投射到receivers上。精确光源，即那些非区域光，只产生完全阴影区域，有时被称为硬阴影(hard shadows)。如果使用面积或体积光源，则产生柔和的阴影。每个阴影可以有一个完全阴影区域，称为本影，和一个部分阴影区域，称为半影。阴影边缘模糊的视为软阴影(soft shadows)。然而，需要注意，只是用低通滤波器模糊硬阴影不能正确渲染软阴影。

![7.1](/img/in-post/rtr7/7-1.jpg)

原书图7.1，阴影术语:light source 光源、occluder 遮光器、receiver 接收器、shadow 阴影、umbra 本影、penumbra 半影。

从图7.2中可以看出，投射阴影的几何图形离接收器越近，软阴影就越清晰。软阴影的本影区域不等于由精确光源产生的硬阴影。相反，软阴影的本影区域会随着光源变大而减小，如果光源足够大，接收器距离遮挡器足够远，它甚至可能消失。软阴影通常是可取的，因为半阴影边缘让观众知道，阴影确实是一个阴影。硬边阴影通常看起来不那么真实，有时会被误解为实际的几何特征，比如表面的折痕。然而，硬阴影比软阴影渲染速度快。

![7.2](/img/in-post/rtr7/7-2.jpg)

原书图7.2，硬阴影和软阴影的混合。板条箱的阴影很锋利，因为遮挡者靠近接收器。人的影子在接触点是尖锐的，随着与遮挡者距离的增加而变软。远处的树枝投下柔和的阴影。

有一个不准确的阴影通常比没有要好。没有一些阴影作为视觉线索，场景往往难以令人信服，更难以理解。眼睛对阴影的形状是相当宽容的。例如，在地板上使用一个模糊的黑色圆圈作为纹理，可以将角色锚定在地面上。

在接下来的部分中，将介绍从场景中的遮挡器实时自动计算阴影的方法。第一部分处理投射在平面表面上的阴影的特殊情况，第二部分介绍更一般的阴影算法，即将阴影投射到任意表面。硬阴影和软阴影都将被覆盖。最后，提出了适用于各种阴影算法的优化技术。

### 1平面阴影

当物体将阴影投射到平面上时，就会出现简单的阴影。本节介绍了几种用于平面阴影(Planar Shadows)的算法，每种算法在阴影的柔度和真实感方面都有所不同。

#### 1.1投影阴影

在这个方案中，二次渲染三维对象以创建阴影。可以导出一个矩阵，将一个对象的顶点投射到平面上。考虑图7.3中的情况，光源位于l处，需要投影的顶点在v处，投影后顶点在p处。下面将计算投影矩阵特殊情况，即阴影平面y = 0时的计算，然后推广到任何平面。

![7.3](/img/in-post/rtr7/7-3.jpg)

原书图7.3，左图：一个光源在l位置，投射阴影到平面y=0处。顶点v被投影到平面上，投射点为p。用相似三角形推导投影矩阵。右图：影子投射到平面上，$\pi :n \cdot x+d$。

我们先求出x坐标的投影。由图7.3左半部分的相似三角形可得

![e7.1](/img/in-post/rtr7/e7.1.jpg)

z坐标也是用同样的方法得到的:$p_z=(l_yv_x-l_xv_y)/(l_y-v_y)$，而y坐标是0。现在这些方程可以转换成投影矩阵M:

![e7.2](/img/in-post/rtr7/e7.2.jpg)

很容易证明Mv = p，这意味着M确实是投影矩阵。

在一般情况下，阴影投射的平面不是y=0，而是$\pi :n \cdot x+d$，如图7.3。我们的目的是找到v投影到p的矩阵。l处的射线，经过v，与平面相交。这就得到了投影点p:

![e7.3](/img/in-post/rtr7/e7.3.jpg)

这个等式转化成公式7.4中的投影矩阵，满足Mv=p:

![e7.4](/img/in-post/rtr7/e7.4.jpg)

如果平面为y = 0，这个矩阵变成了7.2式中的矩阵，即n = (0,1);和d = 0。

要渲染阴影，只需将此矩阵应用于应该在平面π上投射阴影的对象，然后使用深色和无照明效果渲染此投影对象。在实践中，必须采取措施，以避免让投影在接收它们的表面下渲染。一种方法是在投影平面上添加一些偏差，这样阴影三角形总是渲染在平面前面。

一种更安全的方法是首先绘制地平面，然后在关闭z缓冲区的情况下绘制投影的三角形，然后照常渲染其余的几何图形。这样阴影总是在地平面的顶部绘制，因为不进行深度比较。

如果地平面有一个极限，例如，它是一个矩形，投影的阴影可能会落在它的外面，打破了错觉。为了解决这个问题，我们可以使用模板缓冲区。首先，将接收器绘制到屏幕和模板缓冲区。

另一种阴影算法是将阴影渲染成纹理，然后应用到地平面。这种纹理是一种光照贴图，一种调节底层表面强度的纹理(第11.5.1节)。正如我们所看到的，这种将阴影投射到纹理上的想法也允许在曲面上产生半阴影和阴影。此技术的一个缺点是纹理会被放大，单个纹理像素覆盖多个像素，从而打破了错觉。

如果阴影的情况在帧与帧之间没有变化，即光和阴影不相对移动，这种纹理可以重复使用。如果没有发生变化，大多数阴影技术都可以从重复使用帧与帧之间的中间计算结果中获益。

阴影投射器必须在光源和平面接收器之间。如果光源低于物体最高点，就会产生一个反阴影(antishadow)，因为每个顶点都是通过光源投射的。正确的阴影和反阴影如图7.4所示。如果我们投射一个在接收平面以下的物体，也会发生错误，因为它也不应该投射阴影。

![7.4](/img/in-post/rtr7/7-4.jpg)

原书图7.4，左图是正确的阴影，右图是反阴影，因为光源在物体顶点之下。

当然可以显式地剔除和修剪阴影三角形以避免此类错误。下面介绍一种更简单的方法，使用现有的GPU管道来执行带有裁剪的投影。

#### 1.2柔和阴影

投射的阴影可以用各种技术变得柔和。Heckbert和Herf提出了一种产生软阴影的算法。该算法的目标是在显示软阴影的地面上生成纹理。还有一种不那么精确但速度更快的方法。

当光源有一定面积时，就会出现柔和的阴影。一种近似区域光效果的方法是通过在其表面放置几个点状光来采样。对于每一个这样的点状光源，图像都被渲染并缓存到一个缓冲区中。这些图像的平均值就是一个带有柔和阴影的图像。请注意，在理论上，任何生成硬阴影的算法都可以与这种累积技术一起用于生成半阴影。在实践中，以交互速率这样做通常是站不住脚的，因为这会涉及到执行时间。

Heckbert和Herf使用基于视锥的方法生成阴影。想法是将光视为观察者，并且地平面形成了视锥的远裁剪平面。截锥体的宽度足以容纳遮光物体。

一个柔和的阴影纹理是通过生成一系列地平面纹理而形成的。区域光源在其表面上采样，每个位置用于对代表地面的图像进行阴影处理，然后将阴影投射到该图像上。对所有这些图像进行求和平均，生成一个地平面阴影纹理。有关示例参见图7.5的左侧。

![7.5](/img/in-post/rtr7/7-5.jpg)

原书图7.5，左边是使用Heckbert和Herf方法的渲染，使用了256个passes。右边是Haines的方法,使用一个pass。Haines的方法导致本影太大，这在门口和窗户周围尤为明显。

采样区域光方法的一个问题是它看起来像是：点光源发出的多个重叠阴影。同样，对于n次阴影遍历，只能生成n + 1个不同的阴影。大量遍历可以得到准确的结果，但是要付出高昂的代价。 该方法可用于获取（字面意义上的）“真实地面”图像，以测试其他更快算法的质量。一种更有效的方法是使用卷积，即滤波。在某些情况下，模糊单一点产生的硬阴影就足够了，并且可以产生半透明的纹理，可以与真实世界的内容融合，如图7.6。然而，在物体与地面接触的地方，一个均匀的模糊是无法令人信服的。

![7.6](/img/in-post/rtr7/7-6.jpg)

原书图7.6，从上方渲染阴影，然后使图像模糊并在地面上渲染生成阴影纹理。

还有许多其他方法可以提供更好的近似值，但需要付出额外的代价。例如，Haines从投影的硬阴影开始，然后使用从中心的黑暗到边缘的白色渐变来渲染剪影边缘，创造出类似半阴影。参见图7.5的右侧。然而，这些半阴影在物理上是不正确的，因为它们也应该延伸到轮廓边缘内的区域。Iwanicki借鉴了球谐函数的思想，用椭球体近似遮挡以产生柔和的阴影。所有这些方法都有不同的近似值和缺点，但是比平均计算一组大的阴影图像要有效得多。

### 2曲面上的阴影

将平面阴影扩展到曲面的一个简单方法是使用生成的阴影图像作为投影纹理。从光的角度考虑阴影。光能看见的就被照亮;它看不见的东西在阴影里。假设从光源的角度来看，遮挡物被渲染为黑色，否则呈现白色纹理。这个纹理可以投射到接收阴影的表面上。接收器上的每个顶点都有一个(u,v)计算它的纹理坐标，并将纹理应用于它。应用程序可以显式地计算这些纹理坐标。这与前一节中的地面阴影纹理稍有不同，在前一节中，对象被投射到特定的物理平面上。在这里，图像是从光的角度拍摄的，就像投影机里的一帧胶片。

渲染时，投影的阴影纹理修改接收器的表面。它也可以与其他阴影方法相结合，有时主要用于帮助感知物体的位置。例如，在一个平台跳跃的游戏中，主角可能总是被直接赋予一个阴影，即使角色处于完全的阴影中。更精细的算法可以得到更好的结果。例如，Eisemann和Decoret假设有一个矩形顶灯，并创建一个对象水平切片的阴影图像堆栈，然后将其转换为mipmaps或类似的东西。通过使用它的mipmap，每个切片的相应区域与它到接收器的距离成比例，这意味着更远处的切片会投射出更柔和的阴影。

纹理投影方法存在一些严重的缺陷。首先，应用程序必须识别哪些对象是遮挡器，哪些对象是它们的接收者。接收器必须由程序维护，使其比遮光器离光更远，否则阴影就会向后投射。此外，遮挡对象也无法遮挡自身。接下来的两部分将介绍生成正确阴影的算法，而不需要这种干预或限制。

注意，可以通过使用预构建的投射纹理获得各种照明模式。聚光灯只是一个正方形投影的纹理，在其中的一个圆圈定义了灯光。百叶帘效果可以通过由水平线组成的投射纹理来创建。这种类型的纹理被称为light attenuation mask、cookie texture或gobo map。通过简单地将两个纹理相乘，可以将预构建的模式与在动态创建的投影纹理相结合。这些灯在6.9节中进一步讨论了。

### 3阴影体

 Heidmann在1991年提出了一种基于Crow的阴影体方法，该方法巧妙地利用模板缓冲将阴影投射到任意物体上。它可以用于任何GPU，唯一的要求是模板缓冲。它不是基于图像的(不像下面介绍的阴影映射算法)，因此避免了采样问题，从而产生正确的锐利阴影。这有时是一个缺点。例如，角色的衣服可能会折叠起来，形成薄而硬的阴影，从而严重锯齿。由于其不可预测的成本，体积阴影现在很少被使用。我们在这里对算法进行了简要的描述，因为它说明了一些重要的原则和基于这些原则的研究。

首先，想象一个点和一个三角形。将这些线从一个点通过三角形的顶点延伸到无限远处，就得到了一个无限的三面金字塔。三角形下的部分，即不包括点的部分，是一个截断的无限金字塔，而上面部分只是一个金字塔。图7.7对此进行了说明。现在假设这个点是一个点光源。然后，在被截断的金字塔体(三角形下方)内的物体的任何部分都处于阴影中。这个体积称为阴影体shadow volume。

![7.7](/img/in-post/rtr7/7-7.jpg)

原书图7.7，左:点光源的光线通过三角形的顶点延伸，形成一个无限的金字塔。右:上半部分为金字塔，下半部分为无限截椎金字塔，也称阴影体。所有的几何图形都在阴影中。

假设我们查看某个场景，并通过一个像素跟踪来自眼睛的光线，直到光线击中要在屏幕上显示的对象。光线在到达该对象的途中，每当光线穿过阴影体的正面（即面向观察者）的一个面时，我们都会增加一个计数器。因此，每次光线进入阴影时，计数器都会增加。 以相同的方式，每当光线穿过截顶的金字塔的背面时，我们便递减相同的计数器。光线就会从阴影中消失。我们继续进行操作，递增和递减计数器，直到射线照射到要显示在该像素上的对象为止。如果计数器大于0，则该像素处于阴影中;否则就不是。这个原则也适用于有多个三角形投射阴影的情况，如图7.8。

![7.8](/img/in-post/rtr7/7-8.jpg)

原书图7.8，用两种不同的计数方法计算阴影-体积交叉点的二维侧面图。在z-pass体计数中，当射线通过阴影体的正面三角形时，计数递增;当射线通过背面三角形时，计数递减。对于点A，光线进入两个阴影区，加2，然后离开两个阴影区，净计数为0，所以点在光中。在z-fail体计数中，计数从表面以外开始(这些计数以斜体显示)。对于点B处的射线，z-pass方法通过两个正面三角形进行+2计数，而z-fail通过两个背面三角形进行相同计数。点C显示了必须为z-fail阴影体设置上限。射线从点C开始，首先击中一个正面三角形，得到-1。然后，它退出两个阴影体(通过它们的端部，这是此方法正常工作所必需的)，净计数为+1。计数不是零，所以点在阴影中。这两种方法对所观察的表面上的所有点都给出相同的计数结果。

用射线做这件事很费时间。但是有一个更聪明的解决方案:模板缓冲区可以为我们计数。首先，清除模板缓冲区。其次，整个场景被绘制到framebuffer中，只使用不受光材质颜色，以获得颜色缓冲区中的这些阴影组件和z-buffer中的深度信息。第三，关闭z-buffer的更新和对颜色缓冲区的写入(尽管z-buffer 测试仍在进行)，然后绘制阴影体的正面三角形。在此过程中，模板操作被设置为在绘制三角形的任何位置递增模板缓冲区中的值。第四步，使用模板缓冲区完成另一遍，这一次只绘制阴影体的背面三角形。对于此传递，当绘制三角形时，模板中的值递减。只有当渲染的阴影体表面的像素是可见的(即而不是被任何真实的几何图形所隐藏)。在这一点上，模板缓冲区保持每个像素的阴影状态。最后，再次渲染整个场景，这次只使用受光线影响的活性材料组件，并且只显示模板缓冲区中的值为0的地方。值为0表示射线从阴影中消失的次数与进入阴影体的次数相同，此位置被光线照亮。

这种计数方法是阴影体背后的基本思想。阴影体积算法生成的阴影示例如图7.9所示。有方法可以单遍实现该算法。但是，当物体穿透相机的近平面时，会发生计数问题。解决方案称为z-fail，涉及计算隐藏在可见表面后面而不是前面的交叉点。图7.8给出了这种选择的简要概述。

![7.9](/img/in-post/rtr7/7-9.jpg)

原书图7.9，阴影体，左边是角色投射的影子。右边是模型的拉伸三角形。

为每个三角形创建四边形会产生大量的透支。也就是说，每个三角形将创建三个必须渲染的四边形。一个球由一千个三角形组成的四边形有三千个，每一个四边形都可以跨越屏幕。一种解决方案是沿着物体的轮廓边缘只画那些四边形，例如，我们的球体可能只有50个轮廓边缘，所以只需要50个四边形。几何着色器可以用来自动生成这样的轮廓边缘。culling和clamping技术也可用于降低充填成本。

然而，阴影体算法仍然有一个可怕的缺点:极端的可变性。想象一个单独的小三角形。如果相机和光处于完全相同的位置，阴影体成本是最小的。形成的四边形不会覆盖任何像素，因为它们是视图的边缘。只有三角本身关系。假设观察者现在绕着三角形旋转，让它一直在视野中。当摄像机从光源移开时，阴影体的四边形将变得更加可见，并覆盖更多的屏幕，导致更多的计算发生。如果观看者恰好移动到三角形的阴影中，阴影体积将完全覆盖屏幕，与我们最初的视图相比，将花费相当多的时间进行评估。这种可变性使得阴影体在交互应用程序中不可用，而在交互应用程序中，一致的帧速率非常重要。与其他场景一样，朝光方向观看会导致算法成本出现巨大的、不可预测的跳跃。

由于这些原因，阴影体在很大程度上已被应用程序所放弃。然而，考虑到在GPU上访问数据的新方法和不同方法的不断发展，以及研究人员对这种功能的巧妙利用，阴影体可能有一天会重新被广泛使用。 例如，Sintorn等。 概述了阴影体算法，这些算法可提高效率并提出自己的分层加速结构。

下一个算法，阴影映射shadow mapping具有可预测的成本，非常适合GPU，因此构成了许多应用程序中阴影生成的基础。

### 4阴影映射

1978年，Williams提出了一个通用的基于z缓冲的渲染器可以用来快速生成任意物体上的阴影。这个想法是使用z缓冲渲染场景，从光源的位置投射阴影。凡是被光“看见”的都被照亮了，其余的都在阴影里。生成此图像只需要z缓冲，可以关闭灯光、纹理和将值写入颜色缓冲区。

z缓冲区中的每个像素现在都包含最接近光源的对象的z深度。我们称z缓冲区的全部内容为阴影映射shadow map，有时也称为阴影深度映射shadow depth map或阴影缓冲区shadow buffer。要使用shadow map，场景需要第二次渲染，但这次是相对于观察者而言的。在绘制每个图元时，将其在每个像素处的位置与shadow map进行比较。如果一个渲染点离光源的距离比shadow map中相应的值更远，那么这个点就是在阴影中，否则就不是。这种技术是通过使用纹理映射来实现的。见图7.10。shadow map是一个流行的算法，因为它是相对可预测的。构建阴影映射的成本与渲染的图元数量大致成线性关系，并且访问时间是恒定的。shadow map可以生成一次，并在光线和物体不动的场景中重用每一帧，例如用于计算机辅助设计。

![7.10](/img/in-post/rtr7/7-10.jpg)

原书图7.10，Shadow mapping。在左上角，阴影贴图是通过将深度存储到视图中的表面而形成的。右上角，从视线看两个点。在va点可以看到球体，这个点位于shadow map上的texel a。储存在那里的深度并不比va点到光的距离少很多，因此该点被照亮了。在vb点上与光的距离比在texel b上存储的深度要远得多，因此处于阴影中。在左下角是一个场景从光的角度看，白色是更远的。右下角是用这个阴影地图渲染的场景。

当产生一个单独的z缓冲时，光只能“看”一个特定的方向，就像照相机一样。对于像太阳这样的远距离定向光，光的视野被设置成包括所有物体投射的阴影到眼睛看到的可视范围内。光使用正交投影，它的视图需要在x和y中足够宽和足够高来查看这组对象。如果局部光线离投射阴影的物体足够远，一个单一的视锥截体可能就足以包含所有这些。如果光是聚光灯，它有一个自然的截锥体与它相关联，与它的截锥体之外的一切都被认为是没有照明的。

如果局部光源位于场景内部，并被阴影投射器包围，典型的解决方案是使用六视图立方体，类似于立方体环境映射。这些被称为全向阴影图omnidirectional shadow maps。全向映射的主要挑战是避免在两个独立映射相交的接缝处出现工件。King和Newhall深入分析问题并提供解决方案，Gerasimov提供了一些实现细节。Forsyth提出了一个通用的多截锥体分区方案，用于全向灯光，也提供了更多的阴影图分辨率需要的地方。Crytek根据每个视图的投影截头锥体的屏幕空间覆盖设置六个视图的分辨率，所有的图都存储在一个纹理图集中。

并不是场景中的所有对象都需要渲染到光的视图体中。首先，只需要渲染能够投射阴影的对象。例如，如果已知地面只能接收阴影而不能投射阴影，那么它就不必渲染到shadow map中。

根据定义，阴影投射器是在光的视锥中。可以通过多种方式增加或收紧此视锥，使我们可以安全地忽略某些阴影投射器。可见的阴影接收器在光线方向上的最大距离内。任何超过这个距离的东西都不能在可见的接收器上投下阴影。类似地，可见接收器的集合可能会比光原来的x和y视图范围更小。参见图7.11。另一个示例是，如果光源在眼睛的视锥内部，则在此视锥之外的任何物体都不能在接收器上投射阴影。只渲染相关的物体不仅可以节省渲染时间，还可以减小光的截锥体所需的尺寸，从而提高阴影贴图的有效分辨率，从而提高质量。另外，如果光截锥体的近平面离光越远越好，远平面离光越近越好。这样做可以提高z缓冲区的有效精度。

![7.11](/img/in-post/rtr7/7-11.jpg)

原书图7.11，左图光照视野包围视椎。在中间，光的远平面被拉进来，只包括可见的接收器，因此剔除三角形作为投射器;近平面也作了调整。右图，光的截锥体侧面用来约束可见的接收器，剔除了绿色的胶囊。

阴影映射的一个缺点是阴影的质量取决于阴影映射的分辨率(以像素为单位)和z-buffer的数值精度。由于阴影映射是在深度比较时采样的，因此该算法容易产生走样问题，特别是在物体之间的接触点附近。一个常见的问题是自阴影走样，通常被称为“surface acne”或“shadow acne”，其中一个三角形被错误地认为是阴影本身。这个问题有两个原因。一个是处理器精度限制。另一个原因是几何的，因为点样本的值被用来表示一个区域的深度。也就是说，为光线生成的样本几乎从不与屏幕样本位于相同的位置(例如，像素通常在其中心采样)。当光的存储深度值与被观察表面的深度相比较时，光的值可能略低于表面的深度值，从而导致自阴影。这些错误的影响如图7.12所示。

![7.12](/img/in-post/rtr7/7-12.jpg)

原书图7.12，shadow mapping的偏差走样(bias artifacts)。左图，偏差太低，所以会出现自阴影。右图，高偏差导致鞋子不产生接触阴影。阴影贴图的分辨率也很低，导致块状阴影。

帮助避免(不总是消除)各种阴影映射走样的一个常见方法是引入一个偏差因子(bias factor)。在检查阴影图中找到的距离与被测位置的距离时，从接收器的距离中减去一个小偏差。如图7.13。这种偏差可以是一个恒定的值，但是当接收器不是主要面对光线时，这样做可能会失败。一个更有效的方法是使用一个偏置，这个偏置与接收器对光的角度成比例。表面越偏离光线，偏差越大，从而避免这个问题。这种类型的偏差称为坡度比例偏差(slope scale bias)。这两种偏差都可以通过使用诸如OpenGL的glPolygonOffset之类的命令来将每个多边形移离光源。请注意，如果表面直接面对光，则坡度比例偏差根本不会将其向后偏移。因此，为了避免可能出现的精度误差，在坡度比例偏差的基础上使用了常数偏差。坡度比例尺偏差也经常在某一最大值处被限制，因为从光的角度看，当表面接近边缘时，切线值可能非常高。

![7.13](/img/in-post/rtr7/7-13.jpg)

原书图7.13，阴影偏移。这些表面被渲染为高架灯的阴影图，垂直线代表阴影图像素中心，在这些位置记录遮挡物深度。我们想知道表面是否在三个点上发光。最接近的阴影映射深度值显示为×相同的颜色。在左边，如果没有添加任何偏差，蓝色和橙色的样本将被错误地判定为处于阴影中，因为它们离光的距离比对应的阴影图深度更远。在中间，从每个样本中减去恒定的深度偏差，使每个样本都更靠近光线。蓝色样本仍被认为是在阴影中，因为它不比被测试的阴影贴图深度更接近光线。在右边，阴影映射是通过将每个多边形从光的方向按其斜率比例移动而形成的。所有的样本深度现在都比阴影贴图深度更近，所以都被点亮了。

Holbert引入了法线偏移偏置，它首先使接收器的世界空间位置沿表面法线方向稍微偏移一点，与光方向和几何法线之间的角度的正弦成比例。参见图7.24。这不仅改变了深度，还改变了在阴影图上测试样本的x和y坐标。当光的角度变得比表面更浅时，这个偏移量就会增加，采样点离表面足够远以避免自阴影。这种方法可以被想象成把采样点移到接收器上方的一个虚拟表面上。这个偏移量是一个世界空间距离，所以Pettineo建议按阴影图的深度范围缩放它。Pesce提出了一种沿着摄像机视角方向的偏置，这种偏置也可以通过调整阴影图的坐标来实现。其他的偏置方法在7.5节中讨论，因为阴影法也需要测试几个相邻的样本。

过多的偏置会导致光泄露light leaks或 Peter Panning，即物体看起来浮在下表面上。这种假象的产生是因为物体接触点以下的区域，例如，一英尺下的地面，被向前推得太远，所以不会受到阴影。

避免自遮蔽问题的一种方法是仅将背面渲染为阴影贴图。这种被称为第二深度阴影映射(second-depth shadow mapping)的方案在很多情况下都能很好地工作，特别是在不允许手工调整偏移的渲染系统中。当对象是双面的、薄的或相互接触时，就会出现问题。如果一个物体是一个模型，网格的两边都是可见的，例如，一个棕榈叶或一张纸，自阴影可以发生，因为背面和正面在同一个位置。同样，如果不执行任何偏置操作，则轮廓边缘或薄物体附近可能会出现问题，因为在这些区域中，背面接近正面。增加一个偏置可以帮助避免表面问题，但是该方案更容易light leaking，因为接收器和投影器背面在接触点之间没有分隔。参见图7.14。选择哪种方案取决于具体情况。例如，Sousa等人发现使用正面作为太阳阴影，使用背面作为室内灯光最适合他们的应用。

![7.14](/img/in-post/rtr7/7-14.jpg)

原书图7.14，高处光源的阴影贴图表面。在左边，面向光的表面，用红色标记，被发送到阴影图。表面可能被错误地确定为阴影，所以需要远离光线。在中间，仅将背面三角形渲染到阴影贴图中。向下推动这些遮光器的偏置可能会使光泄漏到位置a附近的地面上；向前偏斜会导致阴影标记为b的轮廓边界附近的照明位置被视为阴影。在右边，在阴影图上每个位置的最近的正面和背面三角形之间的中点形成一个中间面。光泄漏可能发生在点c附近(这也可能发生在第二深度阴影映射中)，因为最近的阴影映射样本可能位于该位置左侧的中间表面，因此该点将更接近于光。

注意，对于阴影映射，对象必须是“watertight”(流形和封闭，即固体;第16.3.3节)，或者必须同时渲染地图的正面和背面，否则该物体不能完全投射阴影。Woo提出了一种通用的方法，字面上来说，它试图在仅仅使用正面和背面之间找到一个折中的方法。这个想法是把实体物体渲染到阴影地图上，并踪离光最近的两个表面。这个过程可以通过深度剔除或其他透明相关技术来完成。两个对象之间的平均深度形成一个中间层，其深度用作阴影映射，有时称为对偶阴影映射dual shadow map。如果物体足够厚，自阴影和光泄漏的影响就会最小化。Bavoil等人讨论了处理潜在工件的方法，以及其他实现细节。主要的缺点是使用两个阴影映射相关联的额外成本。迈尔斯讨论了一个艺术家控制的深度层之间的遮光和接收器。

随着观察者的移动，光的可视体积通常会随着阴影投射器的设置而改变大小。这些变化反过来又导致阴影在帧与帧之间轻微移动。这是因为光的阴影图是从光的不同方向采样的，而这些方向与前一组方向不一致。对于定向光，解决方案是强制每个后续生成的阴影地图在世界空间中保持相同的相对texel光束位置。也就是说，您可以将阴影映射看作是在整个世界上施加一个二维网格参考框架，每个网格单元表示地图上的一个像素样本。移动时，将为这些相同网格单元的不同集合生成阴影映射。换句话说，光的视图投射被强制到这个网格上以保持帧与帧之间的一致性。

#### 4.1分辨率增强

类似于纹理的使用，理想情况下，我们希望一个阴影贴图纹理覆盖一个图像像素。如果我们有一个光源位于与眼睛相同的位置，那么阴影映射就可以完美地与屏幕空间像素一一对应(并且没有可见的阴影，因为光线可以精确地照亮眼睛看到的东西)。当光的方向改变时，每像素的比例就会改变，这会造成工件。图7.15显示了一个示例，这种不匹配称为透视混叠。如果表面接近光线，但面向观察者，则单个阴影贴图纹理像素也可以覆盖许多像素。这个问题被称为投影混叠。参见图7.16。块度可以通过增加阴影贴图的分辨率来降低，但这是以增加内存和处理为代价的。

![7.15](/img/in-post/rtr7/7-15.jpg)

原书图7.15，左边的图像是使用标准阴影映射创建的;右边的图像使用LiSPSM。每个阴影贴图的纹理投影被显示出来。这两张阴影图有相同的分辨率，不同之处在于LiSPSM改变了光的矩阵，在靠近观察者的地方提供了更高的采样率。

![7.16](/img/in-post/rtr7/7-16.jpg)

原书图7.16，左边的灯几乎在头顶上。 由于与眼睛的视图相比分辨率较低，因此阴影的边缘有点参差不齐。 在右侧，光线接近地平线，因此每个阴影纹素水平覆盖了更大的屏幕区域，因此产生了更多的锯齿状边缘。

还有另一种方法来创建光的采样模式，使其更接近相机的模式。这是通过改变场景向光投射的方式来实现的。通常我们认为视图是对称的，视向量在截锥体的中心。但是，视图方向仅仅定义了一个视图平面，而没有定义采样的像素。定义截体的窗口可以在这个平面上移动、倾斜或旋转，创建一个四边形，以提供不同的世界映射来查看空间。因为这是线性变换矩阵的本质和GPU的使用，所以四边形仍然是按一定的间隔采样的。采样率可以通过改变光的观察方向和观察窗口的边界来改变。参见图7.17。

![7.17](/img/in-post/rtr7/7-17.jpg)

原书图7.17，对于顶灯，左边地板上的采样与眼睛的频率不匹配。通过改变光线的观察方向和右侧的投影窗口，采样率会偏向于在眼睛附近产生更高密度的纹理。

将光线的视线映射到眼睛的视线有22个自由度。对这个解决方案空间的探索导致了几种不同的算法，它们试图更好地将光的采样率与眼睛的匹配起来。方法包括透视阴影映射(perspective shadow maps PSM)、梯形阴影映射(trapezoidal shadow maps TSM)和光空间透视阴影映射(light space perspective shadow maps LiSPSM)。有关示例，请参见图7.15和图7.26。此类中的技术称为透视变形perspective warping方法。

这些矩阵扭曲算法的一个优点是，除了修改光的矩阵外，不需要额外的工作。每种方法都有自己的优缺点，因为每种方法都可以帮助匹配某些几何图形和照明情况下的采样率，但使其他情况下的采样率更糟。Lloyd等人分析了PSM、TSM和LiSPSM之间的等价关系，对这些方法的采样和混叠问题进行了很好的概述。当光的方向垂直于视图的方向(例如，在头顶上)时，这些方案的效果最好，因为随后可以改变视角变换，使更多的样本更靠近眼睛。

矩阵变形技术无法提供帮助的一种照明情况是，当光线在相机前面并指向相机时。 这种情况被称为dueling frusta，或更通俗地说是“deer in the headlights”。靠近眼睛需要更多阴影贴图样本，但是线性扭曲只会使情况变得更糟。 诸如此类的问题和其他问题，例如质量的突然变化以及相机移动过程中产生的阴影不稳定的质量，使这些方法失去作用。

在查看器所在位置添加更多样本的想法是一个很好的想法，从而产生了为给定视图生成多个阴影贴图的算法。当卡马克在2004年Quakecon的主题演讲中描述这个想法时，这个想法第一次产生了明显的影响。Blow独立实现了这样一个系统。这个想法很简单:生成一组固定的阴影图(可能是不同分辨率的)，覆盖场景的不同区域。在Blow的方案中，四个阴影图嵌套在查看器周围。这样，附近的物体就可以得到高分辨率的图，而远处物体的分辨率就会下降。Forsyth提出了一个相关的想法，为不同的可视对象集生成不同的阴影贴图。在他的设置中避免了如何处理跨越两个阴影贴图边界的对象的转换问题，因为每个对象都有且只有一个与之关联的阴影贴图。Flagship Studios开发了一个融合了这两种理念的系统。一个阴影贴图用于附近的动态对象，另一个用于查看器附近静态对象的网格部分，第三个用于整个场景中的静态对象。第一个阴影贴图每一帧都生成。另外两个只能生成一次，因为光源和几何图形是静态的。尽管所有这些特定的系统现在都相当古老，但不同对象和情况的多映射思想(有些是预先计算的，有些是动态的)是此后发展的算法中的一个共同主题。

2006年Engel、Lloyd等、Zhang等分别独立研究了相同的基本思想。这个想法是通过平行于视图方向的切片将视图截体的体积分割成几个部分。见图7.18。随着深度的增加，每一体积的深度大约是前一体积深度的两到三倍。对于每个视图体，光源可以形成一个紧密的截锥体，然后生成一个阴影贴图。通过使用纹理地图集或阵列，不同的阴影贴图可以被视为一个大的纹理对象，从而最小化缓存访问延迟。所获得的质量改进的比较如图7.19所示。Engel将这种算法命名为级联阴影映射(cascaded shadow maps,CSM)，它比平行分割阴影映射(parallel-split shadow maps)更常用，但两者都出现在文献中，而且实际上是相同的。

![7.18](/img/in-post/rtr7/7-18.jpg)

原书图7.18，左图，从眼睛看到的视台被分成四个部分。右图，为这些体积创建了边界框，该边界框确定了定向光的四个阴影贴图中的每一个渲染的体积。

![7.19](/img/in-post/rtr7/7-19.jpg)

原书图7.19，左图，场景的可视范围广，导致单个2048x2048分辨率的阴影贴图具有透视混叠。右图，沿视图轴放置的四个1024x1024阴影贴图可显着提高质量。插入的红色框中显示了围栏前角的缩放。

该算法实现简单，能够覆盖较大的场景区域，结果合理，鲁棒性强。对dueling frusta问题可以通过在更靠近眼睛的地方以更高的速率采样来解决，并且不存在严重的最坏情况问题。由于这些优点，许多应用使用了级联阴影映射。

