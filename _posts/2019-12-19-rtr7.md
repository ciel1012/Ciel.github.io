---
layout:     post
title:      "Shadows"
subtitle:   "\"《Real-Time Rendering 4th》笔记——第七章 阴影\""
date:       2019-12-19
author:     "Ciel"
header-img: "img/post-bg-rtr.jpg"
catalog: true
mathjax: true
tags:
    - Real-Time Rendering
---

# Shadows

> 本章主要介绍计算阴影的基本原理，并介绍最重要和最流行的实时算法，以及不太流行但是体现了重要原则的方法。

本章使用的术语如图7.1所示，其中occluders将阴影投射到receivers上。精确光源，即那些非区域光，只产生完全阴影区域，有时被称为硬阴影(hard shadows)。如果使用面积或体积光源，则产生柔和的阴影。每个阴影可以有一个完全阴影区域，称为本影，和一个部分阴影区域，称为半影。阴影边缘模糊的视为软阴影(soft shadows)。然而，需要注意，只是用低通滤波器模糊硬阴影不能正确渲染软阴影。

![7.1](/img/in-post/rtr7/7-1.jpg)

原书图7.1，阴影术语:light source 光源、occluder 遮光器、receiver 接收器、shadow 阴影、umbra 本影、penumbra 半影。

从图7.2中可以看出，投射阴影的几何图形离接收器越近，软阴影就越清晰。软阴影的本影区域不等于由精确光源产生的硬阴影。相反，软阴影的本影区域会随着光源变大而减小，如果光源足够大，接收器距离遮挡器足够远，它甚至可能消失。软阴影通常是可取的，因为半阴影边缘让观众知道，阴影确实是一个阴影。硬边阴影通常看起来不那么真实，有时会被误解为实际的几何特征，比如表面的折痕。然而，硬阴影比软阴影渲染速度快。

![7.2](/img/in-post/rtr7/7-2.jpg)

原书图7.2，硬阴影和软阴影的混合。板条箱的阴影很锋利，因为遮挡者靠近接收器。人的影子在接触点是尖锐的，随着与遮挡者距离的增加而变软。远处的树枝投下柔和的阴影。

有一个不准确的阴影通常比没有要好。没有一些阴影作为视觉线索，场景往往难以令人信服，更难以理解。眼睛对阴影的形状是相当宽容的。例如，在地板上使用一个模糊的黑色圆圈作为纹理，可以将角色锚定在地面上。

在接下来的部分中，将介绍从场景中的遮挡器实时自动计算阴影的方法。第一部分处理投射在平面表面上的阴影的特殊情况，第二部分介绍更一般的阴影算法，即将阴影投射到任意表面。硬阴影和软阴影都将被覆盖。最后，提出了适用于各种阴影算法的优化技术。

### 1平面阴影

当物体将阴影投射到平面上时，就会出现简单的阴影。本节介绍了几种用于平面阴影(Planar Shadows)的算法，每种算法在阴影的柔度和真实感方面都有所不同。

#### 1.1投影阴影

在这个方案中，二次渲染三维对象以创建阴影。可以导出一个矩阵，将一个对象的顶点投射到平面上。考虑图7.3中的情况，光源位于l处，需要投影的顶点在v处，投影后顶点在p处。下面将计算投影矩阵特殊情况，即阴影平面y = 0时的计算，然后推广到任何平面。

![7.3](/img/in-post/rtr7/7-3.jpg)

原书图7.3，左图：一个光源在l位置，投射阴影到平面y=0处。顶点v被投影到平面上，投射点为p。用相似三角形推导投影矩阵。右图：影子投射到平面上，$\pi :n \cdot x+d$。

我们先求出x坐标的投影。由图7.3左半部分的相似三角形可得

![e7.1](/img/in-post/rtr7/e7.1.jpg)

z坐标也是用同样的方法得到的:$p_z=(l_yv_x-l_xv_y)/(l_y-v_y)$，而y坐标是0。现在这些方程可以转换成投影矩阵M:

![e7.2](/img/in-post/rtr7/e7.2.jpg)

很容易证明Mv = p，这意味着M确实是投影矩阵。

在一般情况下，阴影投射的平面不是y=0，而是$\pi :n \cdot x+d$，如图7.3。我们的目的是找到v投影到p的矩阵。l处的射线，经过v，与平面相交。这就得到了投影点p:

![e7.3](/img/in-post/rtr7/e7.3.jpg)

这个等式转化成公式7.4中的投影矩阵，满足Mv=p:

![e7.4](/img/in-post/rtr7/e7.4.jpg)

如果平面为y = 0，这个矩阵变成了7.2式中的矩阵，即n = (0,1);和d = 0。

要渲染阴影，只需将此矩阵应用于应该在平面π上投射阴影的对象，然后使用深色和无照明效果渲染此投影对象。在实践中，必须采取措施，以避免让投影在接收它们的表面下渲染。一种方法是在投影平面上添加一些偏差，这样阴影三角形总是渲染在平面前面。

一种更安全的方法是首先绘制地平面，然后在关闭z缓冲区的情况下绘制投影的三角形，然后照常渲染其余的几何图形。这样阴影总是在地平面的顶部绘制，因为不进行深度比较。

如果地平面有一个极限，例如，它是一个矩形，投影的阴影可能会落在它的外面，打破了错觉。为了解决这个问题，我们可以使用模板缓冲区。首先，将接收器绘制到屏幕和模板缓冲区。

另一种阴影算法是将阴影渲染成纹理，然后应用到地平面。这种纹理是一种光照贴图，一种调节底层表面强度的纹理(第11.5.1节)。正如我们所看到的，这种将阴影投射到纹理上的想法也允许在曲面上产生半阴影和阴影。此技术的一个缺点是纹理会被放大，单个纹理像素覆盖多个像素，从而打破了错觉。

如果阴影的情况在帧与帧之间没有变化，即光和阴影不相对移动，这种纹理可以重复使用。如果没有发生变化，大多数阴影技术都可以从重复使用帧与帧之间的中间计算结果中获益。

阴影投射器必须在光源和平面接收器之间。如果光源低于物体最高点，就会产生一个反阴影(antishadow)，因为每个顶点都是通过光源投射的。正确的阴影和反阴影如图7.4所示。如果我们投射一个在接收平面以下的物体，也会发生错误，因为它也不应该投射阴影。

![7.4](/img/in-post/rtr7/7-4.jpg)

原书图7.4，左图是正确的阴影，右图是反阴影，因为光源在物体顶点之下。

当然可以显式地剔除和修剪阴影三角形以避免此类错误。下面介绍一种更简单的方法，使用现有的GPU管道来执行带有裁剪的投影。

#### 1.2柔和阴影

投射的阴影可以用各种技术变得柔和。Heckbert和Herf提出了一种产生软阴影的算法。该算法的目标是在显示软阴影的地面上生成纹理。还有一种不那么精确但速度更快的方法。

当光源有一定面积时，就会出现柔和的阴影。一种近似区域光效果的方法是通过在其表面放置几个点状光来采样。对于每一个这样的点状光源，图像都被渲染并缓存到一个缓冲区中。这些图像的平均值就是一个带有柔和阴影的图像。请注意，在理论上，任何生成硬阴影的算法都可以与这种累积技术一起用于生成半阴影。在实践中，以交互速率这样做通常是站不住脚的，因为这会涉及到执行时间。

Heckbert和Herf使用基于视锥的方法生成阴影。想法是将光视为观察者，并且地平面形成了视锥的远裁剪平面。截锥体的宽度足以容纳遮光物体。

一个柔和的阴影纹理是通过生成一系列地平面纹理而形成的。区域光源在其表面上采样，每个位置用于对代表地面的图像进行阴影处理，然后将阴影投射到该图像上。对所有这些图像进行求和平均，生成一个地平面阴影纹理。有关示例参见图7.5的左侧。

![7.5](/img/in-post/rtr7/7-5.jpg)

原书图7.5，左边是使用Heckbert和Herf方法的渲染，使用了256个passes。右边是Haines的方法,使用一个pass。Haines的方法导致本影太大，这在门口和窗户周围尤为明显。

采样区域光方法的一个问题是它看起来像是：点光源发出的多个重叠阴影。同样，对于n次阴影遍历，只能生成n + 1个不同的阴影。大量遍历可以得到准确的结果，但是要付出高昂的代价。 该方法可用于获取（字面意义上的）“真实地面”图像，以测试其他更快算法的质量。一种更有效的方法是使用卷积，即滤波。在某些情况下，模糊单一点产生的硬阴影就足够了，并且可以产生半透明的纹理，可以与真实世界的内容融合，如图7.6。然而，在物体与地面接触的地方，一个均匀的模糊是无法令人信服的。

![7.6](/img/in-post/rtr7/7-6.jpg)

原书图7.6，从上方渲染阴影，然后使图像模糊并在地面上渲染生成阴影纹理。

还有许多其他方法可以提供更好的近似值，但需要付出额外的代价。例如，Haines从投影的硬阴影开始，然后使用从中心的黑暗到边缘的白色渐变来渲染剪影边缘，创造出类似半阴影。参见图7.5的右侧。然而，这些半阴影在物理上是不正确的，因为它们也应该延伸到轮廓边缘内的区域。Iwanicki借鉴了球谐函数的思想，用椭球体近似遮挡以产生柔和的阴影。所有这些方法都有不同的近似值和缺点，但是比平均计算一组大的阴影图像要有效得多。

### 2曲面上的阴影

将平面阴影扩展到曲面的一个简单方法是使用生成的阴影图像作为投影纹理。从光的角度考虑阴影。光能看见的就被照亮;它看不见的东西在阴影里。假设从光源的角度来看，遮挡物被渲染为黑色，否则呈现白色纹理。这个纹理可以投射到接收阴影的表面上。接收器上的每个顶点都有一个(u,v)计算它的纹理坐标，并将纹理应用于它。应用程序可以显式地计算这些纹理坐标。这与前一节中的地面阴影纹理稍有不同，在前一节中，对象被投射到特定的物理平面上。在这里，图像是从光的角度拍摄的，就像投影机里的一帧胶片。

渲染时，投影的阴影纹理修改接收器的表面。它也可以与其他阴影方法相结合，有时主要用于帮助感知物体的位置。例如，在一个平台跳跃的游戏中，主角可能总是被直接赋予一个阴影，即使角色处于完全的阴影中。更精细的算法可以得到更好的结果。例如，Eisemann和Decoret假设有一个矩形顶灯，并创建一个对象水平切片的阴影图像堆栈，然后将其转换为mipmaps或类似的东西。通过使用它的mipmap，每个切片的相应区域与它到接收器的距离成比例，这意味着更远处的切片会投射出更柔和的阴影。

纹理投影方法存在一些严重的缺陷。首先，应用程序必须识别哪些对象是遮挡器，哪些对象是它们的接收者。接收器必须由程序维护，使其比遮光器离光更远，否则阴影就会向后投射。此外，遮挡对象也无法遮挡自身。接下来的两部分将介绍生成正确阴影的算法，而不需要这种干预或限制。

注意，可以通过使用预构建的投射纹理获得各种照明模式。聚光灯只是一个正方形投影的纹理，在其中的一个圆圈定义了灯光。百叶帘效果可以通过由水平线组成的投射纹理来创建。这种类型的纹理被称为light attenuation mask、cookie texture或gobo map。通过简单地将两个纹理相乘，可以将预构建的模式与在动态创建的投影纹理相结合。这些灯在6.9节中进一步讨论了。

### 3阴影体

 Heidmann在1991年提出了一种基于Crow的阴影体方法，该方法巧妙地利用模板缓冲将阴影投射到任意物体上。它可以用于任何GPU，唯一的要求是模板缓冲。它不是基于图像的(不像下面介绍的阴影映射算法)，因此避免了采样问题，从而产生正确的锐利阴影。这有时是一个缺点。例如，角色的衣服可能会折叠起来，形成薄而硬的阴影，从而严重锯齿。由于其不可预测的成本，体积阴影现在很少被使用。我们在这里对算法进行了简要的描述，因为它说明了一些重要的原则和基于这些原则的研究。

首先，想象一个点和一个三角形。将这些线从一个点通过三角形的顶点延伸到无限远处，就得到了一个无限的三面金字塔。三角形下的部分，即不包括点的部分，是一个截断的无限金字塔，而上面部分只是一个金字塔。图7.7对此进行了说明。现在假设这个点是一个点光源。然后，在被截断的金字塔体(三角形下方)内的物体的任何部分都处于阴影中。这个体积称为阴影体shadow volume。

![7.7](/img/in-post/rtr7/7-7.jpg)

原书图7.7，左:点光源的光线通过三角形的顶点延伸，形成一个无限的金字塔。右:上半部分为金字塔，下半部分为无限截椎金字塔，也称阴影体。所有的几何图形都在阴影中。

假设我们查看某个场景，并通过一个像素跟踪来自眼睛的光线，直到光线击中要在屏幕上显示的对象。光线在到达该对象的途中，每当光线穿过阴影体的正面（即面向观察者）的一个面时，我们都会增加一个计数器。因此，每次光线进入阴影时，计数器都会增加。 以相同的方式，每当光线穿过截顶的金字塔的背面时，我们便递减相同的计数器。光线就会从阴影中消失。我们继续进行操作，递增和递减计数器，直到射线照射到要显示在该像素上的对象为止。如果计数器大于0，则该像素处于阴影中;否则就不是。这个原则也适用于有多个三角形投射阴影的情况，如图7.8。

![7.8](/img/in-post/rtr7/7-8.jpg)

原书图7.8，用两种不同的计数方法计算阴影-体积交叉点的二维侧面图。在z-pass体计数中，当射线通过阴影体的正面三角形时，计数递增;当射线通过背面三角形时，计数递减。对于点A，光线进入两个阴影区，加2，然后离开两个阴影区，净计数为0，所以点在光中。在z-fail体计数中，计数从表面以外开始(这些计数以斜体显示)。对于点B处的射线，z-pass方法通过两个正面三角形进行+2计数，而z-fail通过两个背面三角形进行相同计数。点C显示了必须为z-fail阴影体设置上限。射线从点C开始，首先击中一个正面三角形，得到-1。然后，它退出两个阴影体(通过它们的端部，这是此方法正常工作所必需的)，净计数为+1。计数不是零，所以点在阴影中。这两种方法对所观察的表面上的所有点都给出相同的计数结果。

用射线做这件事很费时间。但是有一个更聪明的解决方案:模板缓冲区可以为我们计数。首先，清除模板缓冲区。其次，整个场景被绘制到framebuffer中，只使用不受光材质颜色，以获得颜色缓冲区中的这些阴影组件和z-buffer中的深度信息。第三，关闭z-buffer的更新和对颜色缓冲区的写入(尽管z-buffer 测试仍在进行)，然后绘制阴影体的正面三角形。在此过程中，模板操作被设置为在绘制三角形的任何位置递增模板缓冲区中的值。第四步，使用模板缓冲区完成另一遍，这一次只绘制阴影体的背面三角形。对于此传递，当绘制三角形时，模板中的值递减。只有当渲染的阴影体表面的像素是可见的(即而不是被任何真实的几何图形所隐藏)。在这一点上，模板缓冲区保持每个像素的阴影状态。最后，再次渲染整个场景，这次只使用受光线影响的活性材料组件，并且只显示模板缓冲区中的值为0的地方。值为0表示射线从阴影中消失的次数与进入阴影体的次数相同，此位置被光线照亮。

这种计数方法是阴影体背后的基本思想。阴影体积算法生成的阴影示例如图7.9所示。有方法可以单遍实现该算法。但是，当物体穿透相机的近平面时，会发生计数问题。解决方案称为z-fail，涉及计算隐藏在可见表面后面而不是前面的交叉点。图7.8给出了这种选择的简要概述。

![7.9](/img/in-post/rtr7/7-9.jpg)

原书图7.9，阴影体，左边是角色投射的影子。右边是模型的拉伸三角形。

为每个三角形创建四边形会产生大量的透支。也就是说，每个三角形将创建三个必须渲染的四边形。一个球由一千个三角形组成的四边形有三千个，每一个四边形都可以跨越屏幕。一种解决方案是沿着物体的轮廓边缘只画那些四边形，例如，我们的球体可能只有50个轮廓边缘，所以只需要50个四边形。几何着色器可以用来自动生成这样的轮廓边缘。culling和clamping技术也可用于降低充填成本。

然而，阴影体算法仍然有一个可怕的缺点:极端的可变性。想象一个单独的小三角形。如果相机和光处于完全相同的位置，阴影体成本是最小的。形成的四边形不会覆盖任何像素，因为它们是视图的边缘。只有三角本身关系。假设观察者现在绕着三角形旋转，让它一直在视野中。当摄像机从光源移开时，阴影体的四边形将变得更加可见，并覆盖更多的屏幕，导致更多的计算发生。如果观看者恰好移动到三角形的阴影中，阴影体积将完全覆盖屏幕，与我们最初的视图相比，将花费相当多的时间进行评估。这种可变性使得阴影体在交互应用程序中不可用，而在交互应用程序中，一致的帧速率非常重要。与其他场景一样，朝光方向观看会导致算法成本出现巨大的、不可预测的跳跃。

由于这些原因，阴影体在很大程度上已被应用程序所放弃。然而，考虑到在GPU上访问数据的新方法和不同方法的不断发展，以及研究人员对这种功能的巧妙利用，阴影体可能有一天会重新被广泛使用。 例如，Sintorn等。 概述了阴影体算法，这些算法可提高效率并提出自己的分层加速结构。

下一个算法，阴影映射shadow mapping具有可预测的成本，非常适合GPU，因此构成了许多应用程序中阴影生成的基础。

### 4阴影映射

1978年，Williams提出了一个通用的基于z缓冲的渲染器可以用来快速生成任意物体上的阴影。这个想法是使用z缓冲渲染场景，从光源的位置投射阴影。凡是被光“看见”的都被照亮了，其余的都在阴影里。生成此图像只需要z缓冲，可以关闭灯光、纹理和将值写入颜色缓冲区。



