---
layout:     post
title:      "Shadows"
subtitle:   "\"《Real-Time Rendering 4th》笔记——第七章 阴影\""
date:       2019-12-19
author:     "Ciel"
header-img: "img/post-bg-rtr.jpg"
catalog: true
mathjax: true
tags:
    - Real-Time Rendering
---

# Shadows

> 本章主要介绍计算阴影的基本原理，并介绍最重要和最流行的实时算法，以及不太流行但是体现了重要原则的方法。

本章使用的术语如图7.1所示，其中occluders将阴影投射到receivers上。精确光源，即那些非区域光，只产生完全阴影区域，有时被称为硬阴影(hard shadows)。如果使用面积或体积光源，则产生柔和的阴影。每个阴影可以有一个完全阴影区域，称为本影，和一个部分阴影区域，称为半影。阴影边缘模糊的视为软阴影(soft shadows)。然而，需要注意，只是用低通滤波器模糊硬阴影不能正确渲染软阴影。

![7.1](/img/in-post/rtr7/7-1.jpg)

原书图7.1，阴影术语:light source 光源、occluder 遮光器、receiver 接收器、shadow 阴影、umbra 本影、penumbra 半影。

从图7.2中可以看出，投射阴影的几何图形离接收器越近，软阴影就越清晰。软阴影的本影区域不等于由精确光源产生的硬阴影。相反，软阴影的本影区域会随着光源变大而减小，如果光源足够大，接收器距离遮挡器足够远，它甚至可能消失。软阴影通常是可取的，因为半阴影边缘让观众知道，阴影确实是一个阴影。硬边阴影通常看起来不那么真实，有时会被误解为实际的几何特征，比如表面的折痕。然而，硬阴影比软阴影渲染速度快。

![7.2](/img/in-post/rtr7/7-2.jpg)

原书图7.2，硬阴影和软阴影的混合。板条箱的阴影很锋利，因为遮挡者靠近接收器。人的影子在接触点是尖锐的，随着与遮挡者距离的增加而变软。远处的树枝投下柔和的阴影。

有一个不准确的阴影通常比没有要好。没有一些阴影作为视觉线索，场景往往难以令人信服，更难以理解。眼睛对阴影的形状是相当宽容的。例如，在地板上使用一个模糊的黑色圆圈作为纹理，可以将角色锚定在地面上。

在接下来的部分中，将介绍从场景中的遮挡器实时自动计算阴影的方法。第一部分处理投射在平面表面上的阴影的特殊情况，第二部分介绍更一般的阴影算法，即将阴影投射到任意表面。硬阴影和软阴影都将被覆盖。最后，提出了适用于各种阴影算法的优化技术。

### 1平面阴影

当物体将阴影投射到平面上时，就会出现简单的阴影。本节介绍了几种用于平面阴影(Planar Shadows)的算法，每种算法在阴影的柔度和真实感方面都有所不同。

#### 1.1投影阴影

在这个方案中，二次渲染三维对象以创建阴影。可以导出一个矩阵，将一个对象的顶点投射到平面上。考虑图7.3中的情况，光源位于l处，需要投影的顶点在v处，投影后顶点在p处。下面将计算投影矩阵特殊情况，即阴影平面y = 0时的计算，然后推广到任何平面。

![7.3](/img/in-post/rtr7/7-3.jpg)

原书图7.3，左图：一个光源在l位置，投射阴影到平面y=0处。顶点v被投影到平面上，投射点为p。用相似三角形推导投影矩阵。右图：影子投射到平面上，$\pi :n \cdot x+d$。

我们先求出x坐标的投影。由图7.3左半部分的相似三角形可得

![e7.1](/img/in-post/rtr7/e7.1.jpg)

z坐标也是用同样的方法得到的:$p_z=(l_yv_x-l_xv_y)/(l_y-v_y)$，而y坐标是0。现在这些方程可以转换成投影矩阵M:

![e7.2](/img/in-post/rtr7/e7.2.jpg)

很容易证明Mv = p，这意味着M确实是投影矩阵。

在一般情况下，阴影投射的平面不是y=0，而是$\pi :n \cdot x+d$，如图7.3。我们的目的是找到v投影到p的矩阵。l处的射线，经过v，与平面相交。这就得到了投影点p:

![e7.3](/img/in-post/rtr7/e7.3.jpg)

这个等式转化成公式7.4中的投影矩阵，满足Mv=p:

![e7.4](/img/in-post/rtr7/e7.4.jpg)

如果平面为y = 0，这个矩阵变成了7.2式中的矩阵，即n = (0,1);和d = 0。

要渲染阴影，只需将此矩阵应用于应该在平面π上投射阴影的对象，然后使用深色和无照明效果渲染此投影对象。在实践中，必须采取措施，以避免让投影在接收它们的表面下渲染。一种方法是在投影平面上添加一些偏差，这样阴影三角形总是渲染在平面前面。

一种更安全的方法是首先绘制地平面，然后在关闭z缓冲区的情况下绘制投影的三角形，然后照常渲染其余的几何图形。这样阴影总是在地平面的顶部绘制，因为不进行深度比较。

如果地平面有一个极限，例如，它是一个矩形，投影的阴影可能会落在它的外面，打破了错觉。为了解决这个问题，我们可以使用模板缓冲区。首先，将接收器绘制到屏幕和模板缓冲区。

另一种阴影算法是将阴影渲染成纹理，然后应用到地平面。这种纹理是一种光照贴图，一种调节底层表面强度的纹理(第11.5.1节)。正如我们所看到的，这种将阴影投射到纹理上的想法也允许在曲面上产生半阴影和阴影。此技术的一个缺点是纹理会被放大，单个纹理像素覆盖多个像素，从而打破了错觉。

如果阴影的情况在帧与帧之间没有变化，即光和阴影不相对移动，这种纹理可以重复使用。如果没有发生变化，大多数阴影技术都可以从重复使用帧与帧之间的中间计算结果中获益。

阴影投射器必须在光源和平面接收器之间。如果光源低于物体最高点，就会产生一个反阴影(antishadow)，因为每个顶点都是通过光源投射的。正确的阴影和反阴影如图7.4所示。如果我们投射一个在接收平面以下的物体，也会发生错误，因为它也不应该投射阴影。

![7.4](/img/in-post/rtr7/7-4.jpg)

原书图7.4，左图是正确的阴影，右图是反阴影，因为光源在物体顶点之下。

当然可以显式地剔除和修剪阴影三角形以避免此类错误。下面介绍一种更简单的方法，使用现有的GPU管道来执行带有裁剪的投影。

#### 1.2柔和阴影

投射的阴影可以用各种技术变得柔和。Heckbert和Herf提出了一种产生软阴影的算法。该算法的目标是在显示软阴影的地面上生成纹理。还有一种不那么精确但速度更快的方法。

当光源有一定面积时，就会出现柔和的阴影。一种近似区域光效果的方法是通过在其表面放置几个点状光来采样。对于每一个这样的点状光源，图像都被渲染并缓存到一个缓冲区中。这些图像的平均值就是一个带有柔和阴影的图像。请注意，在理论上，任何生成硬阴影的算法都可以与这种累积技术一起用于生成半阴影。在实践中，以交互速率这样做通常是站不住脚的，因为这会涉及到执行时间。

Heckbert和Herf使用基于视锥的方法生成阴影。想法是将光视为观察者，并且地平面形成了视锥的远裁剪平面。截锥体的宽度足以容纳遮光物体。

一个柔和的阴影纹理是通过生成一系列地平面纹理而形成的。区域光源在其表面上采样，每个位置用于对代表地面的图像进行阴影处理，然后将阴影投射到该图像上。对所有这些图像进行求和平均，生成一个地平面阴影纹理。有关示例参见图7.5的左侧。

![7.5](/img/in-post/rtr7/7-5.jpg)

原书图7.5，左边是使用Heckbert和Herf方法的渲染，使用了256个passes。右边是Haines的方法,使用一个pass。Haines的方法导致本影太大，这在门口和窗户周围尤为明显。

采样区域光方法的一个问题是它看起来像是：点光源发出的多个重叠阴影。同样，对于n次阴影遍历，只能生成n + 1个不同的阴影。大量遍历可以得到准确的结果，但是要付出高昂的代价。 该方法可用于获取（字面意义上的）“真实地面”图像，以测试其他更快算法的质量。一种更有效的方法是使用卷积，即滤波。在某些情况下，模糊单一点产生的硬阴影就足够了，并且可以产生半透明的纹理，可以与真实世界的内容融合，如图7.6。然而，在物体与地面接触的地方，一个均匀的模糊是无法令人信服的。

![7.6](/img/in-post/rtr7/7-6.jpg)

原书图7.6，从上方渲染阴影，然后使图像模糊并在地面上渲染生成阴影纹理。

还有许多其他方法可以提供更好的近似值，但需要付出额外的代价。例如，Haines从投影的硬阴影开始，然后使用从中心的黑暗到边缘的白色渐变来渲染剪影边缘，创造出类似半阴影。参见图7.5的右侧。然而，这些半阴影在物理上是不正确的，因为它们也应该延伸到轮廓边缘内的区域。Iwanicki借鉴了球谐函数的思想，用椭球体近似遮挡以产生柔和的阴影。所有这些方法都有不同的近似值和缺点，但是比平均计算一组大的阴影图像要有效得多。

### 2曲面上的阴影

将平面阴影扩展到曲面的一个简单方法是使用生成的阴影图像作为投影纹理。从光的角度考虑阴影。光能看见的就被照亮;它看不见的东西在阴影里。假设从光源的角度来看，遮挡物被渲染为黑色，否则呈现白色纹理。这个纹理可以投射到接收阴影的表面上。接收器上的每个顶点都有一个(u,v)计算它的纹理坐标，并将纹理应用于它。应用程序可以显式地计算这些纹理坐标。这与前一节中的地面阴影纹理稍有不同，在前一节中，对象被投射到特定的物理平面上。在这里，图像是从光的角度拍摄的，就像投影机里的一帧胶片。

渲染时，投影的阴影纹理修改接收器的表面。它也可以与其他阴影方法相结合，有时主要用于帮助感知物体的位置。例如，在一个平台跳跃的游戏中，主角可能总是被直接赋予一个阴影，即使角色处于完全的阴影中。更精细的算法可以得到更好的结果。例如，Eisemann和Decoret假设有一个矩形顶灯，并创建一个对象水平切片的阴影图像堆栈，然后将其转换为mipmaps或类似的东西。通过使用它的mipmap，每个切片的相应区域与它到接收器的距离成比例，这意味着更远处的切片会投射出更柔和的阴影。

纹理投影方法存在一些严重的缺陷。首先，应用程序必须识别哪些对象是遮挡器，哪些对象是它们的接收者。接收器必须由程序维护，使其比遮光器离光更远，否则阴影就会向后投射。此外，遮挡对象也无法遮挡自身。接下来的两部分将介绍生成正确阴影的算法，而不需要这种干预或限制。

注意，可以通过使用预构建的投射纹理获得各种照明模式。聚光灯只是一个正方形投影的纹理，在其中的一个圆圈定义了灯光。百叶帘效果可以通过由水平线组成的投射纹理来创建。这种类型的纹理被称为light attenuation mask、cookie texture或gobo map。通过简单地将两个纹理相乘，可以将预构建的模式与在动态创建的投影纹理相结合。这些灯在6.9节中进一步讨论了。

### 3体积阴影

 Heidmann在1991年提出了一种基于Crow的体积阴影的方法，该方法巧妙地利用模板缓冲将阴影投射到任意物体上。



