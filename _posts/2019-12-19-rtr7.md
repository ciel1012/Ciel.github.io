---
layout:     post
title:      "Shadows"
subtitle:   "\"《Real-Time Rendering 4th》笔记——第七章 阴影\""
date:       2019-12-19
author:     "Ciel"
header-img: "img/post-bg-rtr.jpg"
catalog: true
mathjax: true
tags:
    - Real-Time Rendering
---

# Shadows

> 本章主要介绍计算阴影的基本原理，并介绍最重要和最流行的实时算法，以及不太流行但是体现了重要原则的方法。

本章使用的术语如图7.1所示，其中occluders将阴影投射到receivers上。精确光源，即那些非区域光，只产生完全阴影区域，有时被称为硬阴影(hard shadows)。如果使用面积或体积光源，则产生柔和的阴影。每个阴影可以有一个完全阴影区域，称为本影，和一个部分阴影区域，称为半影。阴影边缘模糊的视为软阴影(soft shadows)。然而，需要注意，只是用低通滤波器模糊硬阴影不能正确渲染软阴影。

![7.1](/img/in-post/rtr7/7-1.jpg)

原书图7.1，阴影术语:light source 光源、occluder 遮光器、receiver 接收器、shadow 阴影、umbra 本影、penumbra 半影。

从图7.2中可以看出，投射阴影的几何图形离接收器越近，软阴影就越清晰。软阴影的本影区域不等于由精确光源产生的硬阴影。相反，软阴影的本影区域会随着光源变大而减小，如果光源足够大，接收器距离遮挡器足够远，它甚至可能消失。软阴影通常是可取的，因为半阴影边缘让观众知道，阴影确实是一个阴影。硬边阴影通常看起来不那么真实，有时会被误解为实际的几何特征，比如表面的折痕。然而，硬阴影比软阴影渲染速度快。

![7.2](/img/in-post/rtr7/7-2.jpg)

原书图7.2，硬阴影和软阴影的混合。板条箱的阴影很锋利，因为遮挡者靠近接收器。人的影子在接触点是尖锐的，随着与遮挡者距离的增加而变软。远处的树枝投下柔和的阴影。

有一个不准确的阴影通常比没有要好。没有一些阴影作为视觉线索，场景往往难以令人信服，更难以理解。眼睛对阴影的形状是相当宽容的。例如，在地板上使用一个模糊的黑色圆圈作为纹理，可以将角色锚定在地面上。

在接下来的部分中，将介绍从场景中的遮挡器实时自动计算阴影的方法。第一部分处理投射在平面表面上的阴影的特殊情况，第二部分介绍更一般的阴影算法，即将阴影投射到任意表面。硬阴影和软阴影都将被覆盖。最后，提出了适用于各种阴影算法的优化技术。

### 1平面阴影

当物体将阴影投射到平面上时，就会出现简单的阴影。本节介绍了几种用于平面阴影(Planar Shadows)的算法，每种算法在阴影的柔度和真实感方面都有所不同。

#### 1.1投影阴影

在这个方案中，二次渲染三维对象以创建阴影。可以导出一个矩阵，将一个对象的顶点投射到平面上。考虑图7.3中的情况，光源位于l处，需要投影的顶点在v处，投影后顶点在p处。下面将计算投影矩阵特殊情况，即阴影平面y = 0时的计算，然后推广到任何平面。

![7.3](/img/in-post/rtr7/7-3.jpg)

原书图7.3，左图：一个光源在l位置，投射阴影到平面y=0处。顶点v被投影到平面上，投射点为p。用相似三角形推导投影矩阵。右图：影子投射到平面上，$\pi :n \cdot x+d$。

我们先求出x坐标的投影。由图7.3左半部分的相似三角形可得

![e7.1](/img/in-post/rtr7/e7.1.jpg)

z坐标也是用同样的方法得到的:$p_z=(l_yv_x-l_xv_y)/(l_y-v_y)$，而y坐标是0。现在这些方程可以转换成投影矩阵M:

![e7.2](/img/in-post/rtr7/e7.2.jpg)

很容易证明Mv = p，这意味着M确实是投影矩阵。

在一般情况下，阴影投射的平面不是y=0，而是$\pi :n \cdot x+d$，如图7.3。我们的目的是找到v投影到p的矩阵。l处的射线，经过v，与平面相交。这就得到了投影点p:

![e7.3](/img/in-post/rtr7/e7.3.jpg)

这个等式转化成公式7.4中的投影矩阵，满足Mv=p:

![e7.4](/img/in-post/rtr7/e7.4.jpg)

如果平面为y = 0，这个矩阵变成了7.2式中的矩阵，即n = (0,1);和d = 0。

要渲染阴影，只需将此矩阵应用于应该在平面π上投射阴影的对象，然后使用深色和无照明效果渲染此投影对象。在实践中，必须采取措施，以避免让投影在接收它们的表面下渲染。一种方法是在投影平面上添加一些偏差，这样阴影三角形总是渲染在平面前面。

一种更安全的方法是首先绘制地平面，然后在关闭z缓冲区的情况下绘制投影的三角形，然后照常渲染其余的几何图形。这样阴影总是在地平面的顶部绘制，因为不进行深度比较。

如果地平面有一个极限，例如，它是一个矩形，投影的阴影可能会落在它的外面，打破了错觉。为了解决这个问题，我们可以使用模板缓冲区。首先，将接收器绘制到屏幕和模板缓冲区。

另一种阴影算法是将阴影渲染成纹理，然后应用到地平面。这种纹理是一种光照贴图，一种调节底层表面强度的纹理(第11.5.1节)。正如我们所看到的，这种将阴影投射到纹理上的想法也允许在曲面上产生半阴影和阴影。此技术的一个缺点是纹理会被放大，单个纹理像素覆盖多个像素，从而打破了错觉。

如果阴影的情况在帧与帧之间没有变化，即光和阴影不相对移动，这种纹理可以重复使用。如果没有发生变化，大多数阴影技术都可以从重复使用帧与帧之间的中间计算结果中获益。

阴影投射器必须在光源和平面接收器之间。如果光源低于物体最高点，就会产生一个反阴影(antishadow)，因为每个顶点都是通过光源投射的。正确的阴影和反阴影如图7.4所示。如果我们投射一个在接收平面以下的物体，也会发生错误，因为它也不应该投射阴影。

![7.4](/img/in-post/rtr7/7-4.jpg)

原书图7.4，左图是正确的阴影，右图是反阴影，因为光源在物体顶点之下。

当然可以显式地剔除和修剪阴影三角形以避免此类错误。下面介绍一种更简单的方法，使用现有的GPU管道来执行带有裁剪的投影。