---
layout:     post
title:      "Texturing"
subtitle:   "\"《Real-Time Rendering 4th》笔记——第六章 纹理贴图\""
date:       2019-08-01
author:     "Ciel"
header-img: "img/post-bg-rtr.jpg"
catalog: true
mathjax: true
tags:
    - Real-Time Rendering
---

# Texturing

> 本章详细介绍纹理技术。首先，给出了纹理处理的一般框架。接下来将重点放在使用图像来映射表面，因为这是实时工作中使用的最流行的纹理形式。之后对程序纹理进行了简要的讨论并介绍了几种常用的纹理处理方法。

表面的纹理就是它的外观和触感，想想油画的纹理就知道了。在计算机图形学中，纹理处理是一种使用图像、函数或其他数据源获取一个表面并在每个位置修改其外观的过程。例如，不是精确地表示砖墙的几何形状，而是将砖墙的彩色图像应用于由两个三角形组成的矩形。当矩形被查看时，彩色图像出现在矩形的位置。除非观者靠近墙壁，否则缺乏几何细节将不会被注意到。

然而，一些有纹理的砖墙可能是不令人信服的，不过不是因为缺乏几何形状。例如，如果灰泥是哑光的，而砖是光滑的，那么观察者会注意到两种材料的粗糙度是相同的。为了产生更令人信服的体验，可以在表面应用第二个图像纹理。这种纹理不会改变表面的颜色，而是根据表面的位置改变墙壁的粗糙度。现在砖块和灰泥有了来自图像纹理的颜色和来自这个新纹理的粗糙度值。

观察者可以看到现在所有的砖都是光滑的，而灰泥不是，但请注意，每个砖面似乎是完美的。这看起来不太对，因为砖块的表面通常有些不规则。通过应用凹凸贴图(bump mapping)，砖块的法线可能会发生变化，这样当它们被渲染时，就不会显得非常光滑。为了计算光照，这种纹理会使矩形的原始表面法线方向发生抖动。

从一个浅的视角来看，这种凹凸的错觉可能会被打破。砖块应该突出在灰泥之上，挡住视线。即使从直观的角度看，砖块也应该在灰泥上投下阴影。视差贴图(Parallax mapping)使用纹理在渲染时使表面变形，而视差遮挡贴图(parallax occlusion mapping)将光线投射到高光场纹理上以提高真实感。位移贴图(Displacement  mapping)通过修改形成模型的三角形高度，真正取代了曲面。

![\img\in-post\rtr6\6-1](\img\in-post\rtr6\6-1.jpg)

原书图6.1，纹理。颜色和凹凸贴图被应用到这条鱼，以增加它的视觉细节水平。

### 1纹理管线

纹理是一种有效地建模表面材质和表面粗糙度变化的技术。考虑纹理的一种方法是考虑单个被着色像素的情况。正如在前一章中所看到的，着色是通过考虑材料的颜色和灯光等因素计算出来的。如果存在透明度也会影响样本。纹理是通过修改着色方程中使用的值来实现的。这些值的变化方式通常基于表面的位置。因此，对于砖墙的例子来说，根据表面位置，将表面上任意一点的颜色替换为砖墙图像中相应的颜色。图像纹理中的像素通常称为texels，以便将它们与屏幕上的像素(pixels)区分开来。粗糙度纹理修改了粗糙度值，凹凸纹理改变了法线的方向，所以这些都改变了着色方程的结果。

纹理可以用广义纹理管线来描述。稍后将介绍许多术语并将详细描述管线的每个部分。

空间中的位置是纹理处理的起点。这个位置可以在世界空间中，但更多的时候是在模型的参考框架中，所以当模型移动时，纹理也随之移动。使用Kershaw的术语，空间中的这个点有一个投影(projector)功能，用于获取一组数字，称为纹理坐标(texture mapping)，用于访问纹理。这个过程称为映射(mapping)，因此有了术语纹理映射(texture mapping)。有时纹理图像(texture image)本身被称为纹理映射(texture map)，尽管这并不完全正确。

在使用这些新值访问纹理之前，可以使用一个或多个对应函数将纹理坐标转换为纹理空间。这些纹理空间位置用于从纹理中获取值，例如，它们可以是数组索引到图像纹理中以检索像素。然后，通过值转换函数可能再次转换检索到的值，最后这些新值用于修改表面的某些属性，如材质或着色法线。图6.2详细显示了单个纹理应用程序的这个过程。管线复杂的原因是，每个步骤都为用户提供了一个有用的控件。不过并非所有步骤都需要在任何时候都被激活。

![\img\in-post\rtr6\6-2](\img\in-post\rtr6\6-2.jpg)

原书图6.2，用于单个纹理的通用纹理管线。

使用这个管线，当一个三角形具有砖墙纹理并在其表面生成一个示例时，就会发生这种情况(参见图6.3)。

![\img\in-post\rtr6\6-3](\img\in-post\rtr6\6-3.jpg)

原书图6.3，用于砖墙的管线。

(x,y,z)找到对象的局部坐标系的位置为(-2.3,7.1,88.2)。然后应用投影功能。正如世界地图是三维物体在二维空间中的投影，这里的投影函数通常会改变(x,y,z)向量转化为二元向量(u,v)。本例中使用的投影功能相当于一个正投影(第2.3.1节)，其作用类似于幻灯片投影仪，将砖墙图像投射到三角形表面。要返回到墙面，可以将墙面上的一个点转换成一对值，取值范围从0到1。假设得到的值是(0.32,0.29)。这些纹理坐标将用于确定该位置图像的颜色。砖块纹理的分辨率是256×256，因此对应函数(u,v)乘256，得到(81.92,74.24)。去掉小数，像素(81,74)在砖墙图像中找到，并且色彩值为(0.9,0.8,0.7)。纹理颜色在sRGB颜色空间中，如果要在着色方程中使用颜色，则将其转换为线性空间，得到(0.787,0.604,0.448)(5.6节)。

#### 1.1投影处理

纹理处理的第一步是获取曲面的位置，并将其投影到纹理坐标空间中，通常是二维(u,v)空间。建模通常允许艺术家定义每个顶点的(u,v)坐标。这些可以从投影函数或网格展开算法初始化。艺术家可以用编辑顶点位置同样的方式编辑(u,v)坐标。投影功能通常是通过将空间中的三维点转换为纹理坐标来实现的。建模程序中常用的函数包括球面、圆柱和平面投影。

其他输入可用于投影功能。例如，表面法线可以用来选择六个平面投影方向中的哪一个用于表面。纹理匹配问题发生在面相接的接缝处。Geiss讨论了一种混合它们的技术。Tarini等人描述了多立方体映射(polycube maps)，其中模型映射到一组立方体投影，不同体积的空间映射到不同的立方体。

其他投影功能根本不是投影，而是表面创建和细分的一个隐式部分。例如，参数曲面有一组(u,v)作为其定义的一部分值。参见图6.4。纹理坐标还可以由各种不同的参数生成，比如视图方向、表面温度或任何可以想象的东西。投影功能的目标是生成纹理坐标。把这些作为位置的函数只是一种方法。

![\img\in-post\rtr6\6-4](\img\in-post\rtr6\6-4.jpg)

原书图6.4，不同纹理投影。球形，圆柱形，平面和自然(u,v)从左到右显示。下面一行显示了应用于单个对象(没有自然投影)的每个投影。

非交互式渲染器通常将这些投影功能称为渲染过程本身的一部分。一个简单的投影功能可以满足整个模型，但艺术家往往不得不使用工具来细分模型，并分别应用不同的投影功能。参见图6.5。

![\img\in-post\rtr6\6-5](\img\in-post\rtr6\6-5.jpg)

原书图6.5，如何在一个模型上使用不同的纹理投影。盒映射由六个平面映射组成，每个盒面对应一个平面映射。

在实时工作中，通常在建模阶段使用投影函数，将投影结果存储在顶点上。情况并非总是如此;有时在顶点或像素着色器中应用投影函数是有利的。这样做可以提高精度，并有助于实现各种效果，包括动画(第6.4节)。有些渲染方法，如环境映射(10.4节)，具有自己的特殊投影功能，这些功能按像素计算。

球面投影(图6.4中的左边)将点投射到以某个点为中心的假想球体上。这个投影与Blinn和Newell的环境映射方案中使用的是相同的(第10.4.1节)，之后的方程10.30描述了这个函数。这种投影方法也存在与该节中描述的顶点插值相同的问题。

圆柱投影计算的u纹理坐标与球面投影相同，v纹理坐标计算的是沿圆柱轴线的距离。这种投影对于具有自然轴的物体很有用，比如旋转面。当表面接近垂直于圆柱体轴线时，就会发生畸变。

平面投影就像一束x射线，沿着一个方向平行投影，并将纹理应用于所有表面。它使用正投影(第4.7.1节)。这种类型的投影适用于贴花(第20.2节)。

由于与投影方向平行的表面存在严重的失真，艺术家通常必须手工将模型分解成接近平面的部分。还有一些工具可以通过展开网格或创建一组近乎最优的平面投影来帮助最小化失真，或者帮助这个过程。我们的目标是让每个多边形在纹理的区域中得到更公平的份额，同时尽可能保持网格的连通性。连接性很重要，因为采样伪影可以出现在纹理的不同部分相接的边缘。一个良好展开的网格，也使艺术家的容易工作。第16.2.1节讨论了纹理失真对渲染的负面影响。图6.6显示了用于创建图6.5中雕像的工作区。这个展开过程是一个更大的研究领域，网格参数化(mesh parameterization)的一个方面。感兴趣的读者可以参考Hormann等人的SIGGRAPH课程笔记。

![\img\in-post\rtr6\6-6](\img\in-post\rtr6\6-6.jpg)

原书图6.6，雕像模型的几个较小的纹理，保存在两个较大的纹理中。右边的图显示了如何展开三角形网格并显示在纹理上，以帮助创建三角形网格。

纹理坐标空间并不总是二维平面;有时它是一个三维体。在这种情况下，纹理坐标表示为一个三元素向量(u,v,w)，其中w为沿投影方向的深度。其他系统最多使用四个坐标，通常指定为(s,t,r,q);q是齐次坐标中的第四个值。它就像电影或幻灯片放映机一样，投影纹理的大小随着距离的增加而增加。例如，它可以将一种叫做gobo的装饰性聚光灯图案投射到舞台或其他表面。

纹理坐标空间的另一种重要类型是方向，其中空间中的每个点都由输入方向访问。将这样的空间可视化的一种方法是在一个单位球上的点，每个点上的法线表示用于访问该位置纹理的方向。使用方向参数化的最常见纹理类型是cube map(第6.2.4节)。

同样值得注意的是，一维纹理图像和函数也有它们的用途。例如，在地形模型上，颜色可以由高度决定，例如，低地是绿色的;山峰是白色的。线也可以被纹理;它的一个用途是将雨作为一组半透明图像纹理的长线条。这样的纹理对于从一个值到另一个值的转换也很有用，比如作为查找表。

由于一个表面可以应用多个纹理，因此可能需要定义多个纹理坐标集。无论如何应用坐标值，其思想都是一样的:这些纹理坐标在整个表面内插并用于检索纹理值。然而，在插值之前，这些纹理坐标被相应的函数转换。

#### 1.2映射处理

映射函数(corresponder functions)将纹理坐标转换为纹理空间位置。它们提供了在表面上应用纹理的可行性。映射函数的一个例子是使用API选择要显示的现有纹理的一部分;只有这个子图像将在后续操作中使用。

另一种类型的映射是矩阵变换，它可以应用于顶点着色器或像素着色器。这会平移，旋转，缩放，剪切，或投射纹理的表面。正如第4.1.5节所讨论的，转换的顺序很重要。令人惊讶的是，纹理的转换顺序必须与我们所期望的顺序相反。这是因为纹理变换实际上影响了决定图像位置的空间。图像本身不是被转换的对象;定义图像位置的空间被更改。

另一类映射函数控制应用图像的方式。我们知道(u,v)在[0,1]范围内。但是在这个范围之外会发生什么呢?对应函数决定行为。在OpenGL中，这种类型映射函数称为"包装模式(wrapping mode)";在DirectX中，它被称为"纹理寻址模式(texture addressing mode)。"这种类型的通用映射函数是:

- wrap(DirectX)，repeat(OpenGL)，或tile——图像在表面重复自己;算法上，删除纹理坐标的整数部分。这个函数对于让一个物体的图像重复地覆盖一个表面很有用，并且通常是默认值。

- mirror——图像在表面上重复，但在每一次重复时都会镜像(flipped)。例如，图像通常从0到1，然后在1和2之间反转，然后在2和3之间正常，然后反转，以此类推。这提供了沿着纹理边缘的连续性。

- clamp(DirectX)或clamp to edge(OpenGL)——值超出范围[0,1]部分被限制在这个范围内。这导致图像纹理边缘的重复。当纹理边缘附近发生双线性插值时，此功能可用于避免从纹理的相对边缘意外地采样。

- border (DirectX)或clamp to border (OpenGL)——超出[0;1]的纹理坐标使用单独指定的边框颜色渲染。例如，这个函数可以很好地在单色表面上呈现贴花，因为纹理的边缘将与边框颜色平滑地混合。

参见图6.7。这些对应的函数可以为每个纹理轴分配不同的值，例如纹理可以沿着u轴重复，也可以限制在v轴上。在DirectX中，还有一个mirror one模式，它沿着纹理坐标的零值对纹理进行一次镜像，然后进行箝位，这对于对称贴花非常有用。

![\img\in-post\rtr6\6-7](\img\in-post\rtr6\6-7.jpg)

原书图6.7，图像纹理重复repeat，镜像mirror，夹紧clamp和边框border功能。

重复平铺纹理是一种为场景添加更多视觉细节的廉价方法。然而，这种方法在重复三次纹理之后，通常看起来并不令人信服，因为眼睛会识别出图案。避免这种周期性问题的常见解决方案是将纹理值与另一个非平铺纹理相结合。这种方法可以得到很大的扩展，如Andersson所描述的商业地形绘制系统所示。该系统中，根据地形类型、高度、坡度等因素，将多种纹理进行组合。纹理图像还与几何模型(如灌木丛和岩石)在场景中的位置相关联。

避免周期性的另一个选择是使用着色器程序来实现特殊的映射函数，这些函数随机地重新组合纹理样式或平铺。Wang tiles就是这种方法的一个例子。Wang tile 是一组边缘匹配的方砖。在纹理处理过程中，tiles是随机选择的。Lefebvre和Neyret使用依赖的纹理读取和表实现了类似类型的映射函数，以避免模式重复。

最后一个映射函数是隐式的，由图像的大小导出。纹理通常应用在[0,1]对于u和v。如砖墙的例子所示，通过将这个范围内的纹理坐标乘以图像的分辨率，可以得到像素的位置。指定(u,v)取值范围[0,1]的优点是可以交换不同分辨率的图像纹理，而不需要改变模型顶点上存储的值。

#### 1.3纹理值

在使用相应的函数生成纹理空间坐标后，使用坐标获取纹理值。对于图像纹理，这是通过访问纹理来从图像中检索图素信息来实现的。第6.2节详细讨论了这一过程。图像纹理在实时工作中占绝大多数，但也可以使用程序函数。在程序纹理的情况下，从纹理空间位置获取纹理值的过程不涉及内存查找，而是一个函数的计算。程序纹理将在6.3节中进一步描述。

最直接的纹理值是用于替换或修改表面颜色的RGB三元组;类似地，可以返回单个灰度值。返回的另一种数据类型是RGB$\alpha$，如第5.5节所述。alpha值通常是颜色的不透明度，它决定了颜色对像素的影响程度。也就是说，任何其他值都可以存储，比如表面粗糙度。还有许多其他类型的数据可以存储在图像纹理中，我们将在详细讨论凹凸贴图时看到(第6.7节)。

从纹理返回的值在使用之前可以选择进行转换。这些转换可以在着色器程序中执行。一个常见的例子是将数据从无符号范围(0.0-1.0)映射到有符号范围(-1.0-1.0)，用于对存储在颜色纹理中的法线进行着色。

### 2图像纹理

在图像纹理处理中，二维图像被有效地贴在一个或多个三角形的表面上。我们已经完成了计算纹理位置的过程;现在我们将讨论从给定位置的图像纹理中获取纹理值的问题和算法。在本章的其余部分，图像纹理将被简单地称为纹理。此外，当我们在这里提到像素的单元格时，我们指的是围绕该像素的屏幕网格单元格。正如第5.4.1节所讨论的，像素实际上是一个显示的颜色值，它可以(而且应该)被与其相关的网格单元格之外的示例所影响。

在本节中，我们特别关注快速采样和处理纹理图像的方法。第5.4.2节讨论了锯齿问题，特别是对象的边缘渲染问题。纹理也可能有采样问题，但它们发生在正在渲染的三角形的内部。

像素着色器通过将纹理坐标值传递给texture2D之类的调用来访问纹理。这些值在(u,v)纹理坐标，由对应函数映射到范围[0.0,1.0]。GPU负责将这个值转换为texel坐标。在不同的api中，纹理坐标系之间有两种主要的区别。在DirectX中，纹理的左上角为(0,0)，右下角为(1,1)。这与有多少图像类型存储它们的数据相匹配，第一行是文件中的第一个。在OpenGL中，(0,0)位于左下角，y轴对比DirectX是翻转的。texel具有整数坐标，但我们通常希望访问texel之间的一个位置并在其中进行混合。这就引出了一个问题:像素中心的点坐标是什么。Heckbert讨论了两种可能的系统:截断(truncating)和舍入(rounding)。DirectX 9将每个中心定义为(0.0,0.0)——这使用四舍五入。这个系统有点混乱，因为左上角的像素点在DirectX的原点处，然后有值(-0.5，-0.5)。DirectX 10继续修改OpenGL的系统，其中texel的中心具有分数值(0.5,0.5)——截短(floor)，或者更准确地说就是小数被舍弃。floor是一个更自然的系统，可以很好地映射到语言，比如像素(5,9)定义u坐标的范围为5.0-6.0,v坐标的范围为9.0-10.0。

这里值得解释的一个术语是依赖纹理读取(dependent texture read)，它有两个定义。第一种尤其适用于移动设备。当通过texture2D或类似的方法访问纹理时，当像素着色器计算纹理坐标而不是使用顶点着色器传入的未经修饰的纹理坐标时，就会发生依赖的纹理读取。注意，这意味着对传入的纹理坐标进行任何更改，即使是交换u和v值这样的简单操作。旧的移动gpu，那些不支持OpenGL ES 3.0的gpu，在着色器没有依赖纹理读取时运行得更好，因为可以预先获取texel数据。这个术语的另一个更古老的定义对于早期的台式机gpu尤其重要。在这个上下文中，当一个纹理的坐标依赖于之前一些纹理值的结果时，就会发生依赖纹理读取。例如，一个纹理可能会更改着色法线，这反过来又会更改用于访问cube map的坐标。这种功能在早期的gpu上是有限的，甚至是不存在的。今天，这种读取可能会影响性能，这取决于在批处理中计算的像素数量以及其他因素。有关更多信息，请参见第23.8节。

gpu中使用的纹理图像大小通常为$2^m\times2^n$个纹理，其中m和n是非负整数。这些被称为2的幂纹理(power-of-two ,POT)。现代gpu可以处理任意大小的非二幂(NPOT)纹理，这允许将生成的图像作为纹理处理。然而，一些较老的移动gpu可能不支持NPOT纹理的mipmapping(第6.2.2节)。图形加速器对纹理大小有不同的上限。例如，directx12最多允许$16384^2$个texel。

假设我们有一个大小为256×256的纹理，并且我们想把它用作正方形上的纹理。只要投影在屏幕上的正方形与纹理大小大致相同，那么正方形上的纹理看起来就几乎与原始图像一样。但是，如果投影的正方形所包含的像素是原始图像的十倍(称为放大)，或者投影的正方形只覆盖屏幕的一小部分(称为缩小)，会发生什么呢?答案是，这取决于您决定对这两种不同的情况使用哪种采样和筛选方法。

本章讨论的图像采样和过滤方法适用于从每个纹理中读取的值。然而，期望的结果是防止最终渲染的图像中的锯齿，这在理论上需要采样和过滤最终像素的颜色。这里的区别是过滤着色方程的输入，还是过滤输出。只要输入和输出是线性相关的(这对于输入来说是正确的，比如颜色)，那么过滤单独的纹理值就相当于过滤最终的颜色。然而，许多存储在纹理中的着色器输入值，如表面法线和粗糙度值，与输出有非线性关系。标准的纹理过滤方法可能对这些纹理不起作用，导致锯齿。第9.13节讨论了过滤这些纹理的改进方法。

#### 2.1放大

在图6.8中，一个大小为48×48 texels的纹理被纹理化到一个正方形上，并且这个正方形相对于纹理大小更大，因此底层的图形系统必须放大纹理。放大最常用的滤波技术是最近邻(实际的滤波器称为框式滤波器——参见5.4.1节)和双线性插值。还有三次卷积，它使用4×4或5×5个纹理数组的加权和。这使得更高的放大质量。虽然本地硬件支持三次卷积(也称为双三次插值bicubic interpolation)目前并不常见，但它可以在着色器程序中执行。

![\img\in-post\rtr6\6-8](\img\in-post\rtr6\6-8.jpg)

原书图6.8，纹理放大48×48图像到320×320像素。左:最近邻滤波，每个像素选择最近的图素。中间:双线性滤波使用加权平均的四个最近的图素。右:使用5×5个最接近的图素的加权平均值进行三次滤波。

在图6.8的左侧，使用了最近邻方法。这种放大技术的一个特点是单个纹理可能变得明显。这种效果称为像素化，之所以会发生这种情况，是因为该方法在放大时取距离每个像素中心最近的texel的值，从而产生块状外观。虽然这种方法的质量有时很差，但它只需要为每个像素获取一个texel。

在同一图的中间图像中，使用双线性插值(有时称为线性插值)。对于每个像素，这种滤波方法对相邻的四个纹理进行插值，并在二维空间中进行线性插值，得到像素的混合值。结果更加模糊，使用最近邻方法产生的锯齿已经消失。作为一个实验，试着在眯眼的时候看左边的图片，因为这和低通滤波器的效果差不多，而且更能显示脸部。

回到之前的砖块纹理示例:在不降低分数的情况下，我们得到(pu,pv) = (81.92,74.24)。我们在这里使用OpenGL的左下角原点texel坐标系，因为它与标准的笛卡尔坐标系相匹配。我们的目标是在四个最近的texel之间插入，使用它们的texel中心来定义一个texel大小的坐标系统。参见图6.9。要找出最近的四个像素，我们要减去像素中心分数(0.5,0.5)从我们的样本位置，给出(81.42,73.74)。去掉分数后，距离最近的四个像素的范围为(x,y) = (81,73)到(x + 1,y +1) = (82,74)。分数部分，(0.42,0.74)对于我们的例子，是样本相对于四个texel中心形成的坐标系的位置。我们将这个位置表示为(u',v')。

![\img\in-post\rtr6\6-9](\img\in-post\rtr6\6-9.jpg)

原书图6.9，双线性插值。所涉及的四个texel由左边的四个正方形表示，texel中心为蓝色。右边是由四个texel的中心组成的坐标系。

将纹理访问函数定义为t(x,y)，其中x和y是整数，返回texel的颜色。任意位置(u',v')可以计算为一个两步过程。首先，底部的texels, t(x,y)和t (x + 1,y),水平插值(使用u')，对于最上面的两个texel也类似，t(x,y + 1)和t(x + 1,y + 1)。对于底部的texel，我们得到(1-u')t(x,y) + u't(x + 1,y)(图6.9中底部的绿色圆圈)，对于顶部(1-u')t (x,y + 1) + u't(x + 1,y + 1)(顶部绿色圆圈)。然后将这两个值垂直插值(使用v')，因此双线性插值的颜色b$(p_u,p_v)$为

![\img\in-post\rtr6\e1](\img\in-post\rtr6\e1.jpg)

直观地说，靠近示例位置的texel在实际值中更大。这就是我们在这个方程中看到的。右上角的texel (x + 1,y + 1)对u'v'有影响。注意对称性:右上角的影响等于左下角与采样点形成的矩形面积。回到我们的示例，这意味着从这个texel检索到的值将乘以0.42×0.74，具体来说是0.3108。从这个texel顺时针方向，其他乘数是0.42×0.26，0.58×0.26，0.58×0.74，所有这四个权重之和为1.0。

对于伴随放大而来的模糊，一个常见的解决方案是使用细节纹理(detail textures)。这些纹理代表了新的表面细节，从手机上的划痕到地形上的灌木丛。这样的细节被叠加到放大的纹理上，作为一个单独的纹理，在不同的尺度上。细节纹理的高频重复图案，结合低频放大纹理，具有类似于使用单一高分辨率纹理的视觉效果。

双线性插值在两个方向上线性插值。然而线性插值不是必需的。例如，一个纹理由棋盘图案中的黑白像素组成。使用双线性插值可以得到不同灰度的纹理样本。通过重新映射，例如，所有低于0.4的灰色都是黑色的，所有高于0.6的灰色都是白色的，而那些介于两者之间的灰色被拉伸来填补空白，纹理看起来更像一个棋盘格，同时也给了一些纹理之间的混合。参见图6.10。

![\img\in-post\rtr6\6-10](\img\in-post\rtr6\6-10.jpg)

原书图6.10，最近邻方法，双线性插值，以及使用相同的2×2个棋盘纹理重新映射部分的方式。注意，由于纹理和图像网格并不完全匹配，因此最近邻采样给出的正方形大小略有不同。

使用高分辨率纹理也有类似的效果。例如，假设每个检查器正方形由4×4个texel组成，而不是1×1。围绕每个检查器的中心，插入的颜色将完全是黑色或白色。

在图6.8的右边，使用了一个双三次滤波器，剩余的块度基本上被去掉了。值得注意的是，双三次滤波器比双线性滤波器消耗高。然而，许多高阶滤波器可以表示为重复线性插值(也参见第17.1.1节)。因此，纹理单元中用于线性插值的GPU硬件可以通过几个查找来使用。

如果双三次滤波器被认为过于昂贵，Quilez提出了一种简单的技术，使用平滑曲线在一组2×2个texels之间插入。我们首先描述曲线，然后是技术。两种常用的曲线是平滑步长曲线(smoothstep curve)和五次曲线(quintic curve):

![\img\in-post\rtr6\e2](\img\in-post\rtr6\e2.jpg)

当您想要平滑地从一个值插入到另一个值时，这些方法非常有用。平滑步长曲线具有s'(0)=s'(1)=0的性质，在0和1之间是光滑的。五次曲线具有相同的性质，但q"(0)=q"(1)=0，即二阶导数在曲线的起点和终点也是0。这两条曲线如图6.11所示:

![\img\in-post\rtr6\6-11](\img\in-post\rtr6\6-11.jpg)

原书图6.11，平滑步长曲线s(x)(左)和五次曲线q(x)(右)。

该技术首先计算(u‘,v’)(与公式6.1和图6.9中使用的方法相同)，首先将样本乘以纹理尺寸并添加0.5。整数部分保留到后面，分数存储在u‘和v’中，范围在[0,1]。将(u',v')变换$(t_u,t_v)=(q(u'),q(v'))$，仍然在[0,1]。最后减去0.5，再把整数部分加回去;得到的u坐标然后除以纹理宽度，v也是一样。此时，新的纹理坐标与GPU提供的双线性插值查找一起使用。注意，这个方法将在每个texel处给出一个平台，这意味着，如果texel位于RGB空间中的一个平面上，那么这种类型的插值将会给出一个光滑的，但仍然是阶梯状的外观，这可能并不总是需要的。参见图6.12。

![\img\in-post\rtr6\6-12](\img\in-post\rtr6\6-12.jpg)

原书图6.12，四种不同的方法来放大一维纹理。橙色圆圈表示texel的中心以及texel值(高度)。从左到右:最近邻，线性，使用每对相邻的纹理之间的五次曲线，使用三次插值。

#### 2.2缩小

当纹理最小化时，几个纹理可能覆盖一个像素的单元格，如图6.13。得到每个像素的正确颜色值,你应该整合纹理对像素的影响。然而，要精确地确定一个特定像素附近的所有texels的确切影响是困难的，而且实际上不可能实时完美地做到这一点。

![\img\in-post\rtr6\6-13](\img\in-post\rtr6\6-13.jpg)

原书图6.13，缩小：通过一排像素单元格显示棋盘格纹理正方形的视图，大致显示了一些纹理如何影响每个像素。

因为这个限制，CPUs上使用了几种方法。一种方法是使用最邻近法，工作原理与相应的放大滤波器完全相同，即它选择在像素单元的中心可见的texel。这种滤波器可能会导致严重的锯齿问题。在图6.14中，最上面的图使用了最近邻法。在水平方向上，由于选择了表示一个像素的众多纹理中的一个来表示表面，所以出现了伪影。当表面相对于观察者移动时，这样的伪影更加明显，并且是所谓的时间锯齿(temporal aliasing)的一种表现。

![\img\in-post\rtr6\6-14](\img\in-post\rtr6\6-14.jpg)

原书图6.14，顶部图像使用点采样(最近邻)渲染，中间使用mipmapping渲染，底部使用求和面积表渲染。

另一种常用的滤波器是双线性插值，其工作原理与放大滤波器完全相同。这个滤波器只比最小化的最近邻方法稍微好一点。它混合了四个纹理而不是仅仅使用一个，但是当一个像素受到四个以上的纹理的影响时，滤波器很快就会失效并产生锯齿。

更好的解决方案是可能的。如5.4.1节所述，锯齿问题可以通过采样和滤波技术来解决。纹理的信号频率取决于其纹理在屏幕上的间距。由于Nyquist限制，我们需要确保纹理的信号频率不大于采样频率的一半。例如，假设一个图像是由交替的黑白线组成的，中间有一个texel。然后波长是两个texel宽(从黑线到黑线)，所以频率是1/2。若要在屏幕上正确显示此纹理，则频率必须至少为1/2×2，即，每个texel至少有一个像素。所以，对于一般的纹理，每个像素最多应该有一个texel来避免锯齿。

为了达到这个目的，要么提高像素的采样频率，要么降低纹理频率。前一章讨论的抗锯齿方法给出了提高像素采样率的方法。然而这些只有限的增加采样频率。为了更好地解决这一问题，各种纹理细化算法应运而生。

所有纹理抗锯齿算法的基本思想都是一样的:预处理纹理并创建数据结构，这些数据结构将帮助计算一组纹理在像素上的效果的快速近似。对于实时工作，这些算法的特点是使用固定的时间和资源执行。以这种方式，每个像素使用固定数量的样本并组合以计算（可能大量）texels的效果。

**Mipmapping**

最流行的纹理抗锯齿方法叫做mipmapping。它以某种形式在现在生成的所有图形加速器上实现。“Mip”在拉丁语中是“很多东西在一个小地方”的意思，这里指将原始纹理反复过滤成更小的图像的过程。

当使用mipmapping最小化过滤器时，在实际渲染之前，原始纹理会被一组更小版本的纹理替代。纹理(在0级)被向下采样到原始区域的四分之一，每个新的texel值通常计算为原始纹理中四个相邻texel的平均值。新的一级纹理有时被称为原始纹理的子纹理。递归地执行缩减，直到纹理的一个或两个维度都等于一个texel。这个过程如图6.15所示。作为一个整体的图像集通常被称为mipmap chain。

![\img\in-post\rtr6\6-15](\img\in-post\rtr6\6-15.jpg)

原书图6.15，一个mipmap是通过获取原始图像(0级)，在金字塔的底部，将每个2×2个区域平均为下一层的texel值而形成的。纵轴是第三个纹理坐标d，在图中d不是线性的;它是一种度量方法，用来度量一个样本用于插值的两个纹理级别。

形成高质量mipmap的两个重要因素是良好的滤波和伽马校正。形成mipmap级别的常用方法是取每2×2组texel的平均值，以获得mip texel值。使用的盒型过滤器可能是最差的过滤器之一。这可能会导致质量很差，因为它会不必要地模糊低频，同时保留一些导致锯齿的高频。最好使用高斯、Lanczos、Kaiser或类似的过滤器。一些api支持GPU本身更好的滤波。在纹理的边缘附近，过滤时必须注意纹理是重复的还是单一的复制。

对于非线性空间中编码的纹理(如大多数颜色纹理)，在过滤时忽略gamma校正将修改mipmap级别的感知亮度。当你离物体越远，使用未校正的mipmap，物体整体看起来就越暗，对比度和细节也可以被改变。因此，将这些纹理从sRGB转换为线性空间(第5.6节)，在该空间中执行所有mipmap过滤，并将最终结果转换回sRGB颜色空间进行存储是非常重要的。大多数api都支持sRGB纹理，因此可以在线性空间中正确生成mipmap并将结果存储在sRGB中。当访问sRGB纹理时，它们的值首先被转换到线性空间，以便正确地执行放大和缩小。

正如前面提到的，一些纹理与最终的着色颜色有着非线性关系。虽然这在一般情况下会造成过滤问题，但是mipmap生成对这个问题特别敏感，因为要过滤成百上千个像素。为了获得最佳结果，通常需要使用专门的mipmap生成方法。这些方法详见第9.13节。

纹理化时访问此结构的基本过程很简单。 屏幕像素包围纹理本身的区域。当像素的区域投射到纹理上时(图6.16)，它包含一个或多个纹理。使用像素的单元格边界并不完全正确，但是这里使用它是为了简化表示。单元格外部的texels可以影响像素的颜色如5.4.1之前看到的部分。我们的目标是粗略地确定像素中有多少纹理。有两种常用的计算方法用于计算d（OpenGL称为$\lambda$，也称为细节的纹理级别texture level of detail）。一种是利用像素单元形成的较长的四边形边缘来近似像素的覆盖范围;另一种方法是使用四个不同值($\partial u/\partial x,\partial v/\partial x,\partial u/\partial y,\partial u/\partial y$)中的最大绝对值作为度量。每个差分是纹理坐标相对于屏幕轴的变化量的度量。例如，$\partial u/\partial x$是一个像素的u纹理值沿屏幕x轴的变化量。有关这些方程的更多信息，请参见Williams的原始文章或Flavell的文章或Pharr的文章。McCormack等人用最大绝对值法讨论了锯齿的引入，他们给出了一个替代公式。Ewins等分析了几种质量相当的算法的硬件成本。

![\img\in-post\rtr6\6-16](\img\in-post\rtr6\6-16.jpg)

原书图6.16，在左边是一个正方形像素单元和它的纹理视图。右边是像素单元在纹理本身上的投影。

这些梯度值可用于使用shader Model 3.0或更新版本的像素着色器程序。因为它们是基于相邻像素值之间的差异，它们在受动态流控制影响的像素着色器部分不可访问(第3.8节)。对于要在这样的部分中执行的纹理读取(例如，在循环中)，必须更早地计算导数。注意，由于顶点着色器不能访问梯度信息，梯度或细节级别需要在顶点着色器本身计算，并在使用顶点纹理时提供给GPU。

#### 2.3体积纹理

### 3程序纹理

### 4纹理动画

### 5材质贴图

### 6透明贴图

### 7凹凸贴图

### 8视差贴图

### 9纹理光照
