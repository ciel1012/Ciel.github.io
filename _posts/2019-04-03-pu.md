---
layout:     post
title:      "The Graphics Processing Unit"
subtitle:   "\"《Real-Time Rendering 4th》笔记——第三章 图形处理器\""
date:       2019-04-03
author:     "Ciel"
header-img: "img/post-bg-rtr.jpg"
tags:
    - Real-Time Rendering
    - 笔记
---

# The Graphics Processing Unit

> 这章介绍了GPU渲染管线的组成，可编程着色技术的发展过程，以及Vertex Shader、Tessellation Stage、Geometry Shader、Pixel Shader、Merging Stage、Compute Shader。

1. [Data-Parallel Architectures 数据并行处理架构](#数据并行处理架构)

2. [GPU Pipeline Overview GPU渲染管线概述](#gpu渲染管线概述)

3. [The Programmable Shader Stage 可编程着色阶段](#可编程着色阶段)

4. [The Evolution of Programmable Shading and APIs 可编程着色和API的发展](#可编程着色和api的发展)

5. [The Vertex Shader 顶点着色器](#顶点着色器)

6. [The Tessellation Stage 细分阶段](#细分阶段)

7. [The Geomtry Shader 几何着色器](#几何着色器)

8. [The Pixel Shader 像素着色器](#像素着色器)

9. [The Merging Stage 合并阶段](#合并阶段)

10. [The Compute Shader 计算着色器](#计算着色器)

### 数据并行处理架构

- 不同的处理器体系结构使用不同的策略来避免停滞。为了最小化延迟的影响，CPU芯片的大部分由快速本地缓存组成，内存中充满了接下来可能需要的数据。CPU可以有多个处理器，但是每个处理器都以串行方式运行代码（有限的SIMD向量处理是小例外）。CPU还通过使用诸如分支预测、指令重新排序、寄存器重命名和缓存预取等智能技术来避免停机

- GPU的大部分芯片区域用于一组大的处理器，称为着色器内核，通常有数千个。GPU是一个流处理器，它依次处理有序的相似数据。因为一组顶点或像素有这种相似性，GPU可以大规模处理这些并行数据。另一个重要因素是，这些调用尽可能独立，它们不需要调用相邻数据信息，也不共享可写内存位置。这个规则有时会被打破，以允许新的和有用的功能，但是这种例外是以潜在的延迟为代价的，因为一个处理器可能会等待另一个处理器完成它的工作。

- GPU针对吞吐量进行了优化，并根据数据处理的最大速率进行优化。然而，这种快速处理是有代价的。由于用于缓存和控制逻辑的芯片面积更小，每个着色器内核的延迟通常比CPU处理器遇到的延迟要高得多。

- GPU将指令执行逻辑与数据分离，对固定数量的着色器程序同步执行相同命令，这种方式称为单指令多数据（single instruction multiple data,SIMD）。

- 每个片段的像素着色器调用称为线程，这种类型的线程不同于CPU线程。使用相同着色程序的线程被捆绑成组，NVIDIA称为warps，AMD称为wavefronts。假设我们有2000个线程要执行。NVIDIA gpu上的warps包含32个线程。这将产生2000÷32 = 62.5 warps，这意味着分配了63个warps，其中一个warp是半空的。

- 着色器程序的结构是影响效率的一个重要特性。一个主要因素是每个线程的寄存器使用量。着色器程序与每个线程关联所需的寄存器越多，可以驻留在GPU中的线程就越少，因此wraps也就越少。wraps 的短缺可能意味着无法通过交换减轻延迟。可使用的warp数量称为占用率。高占用率意味着有许多可用于处理的warp，因此处理器空闲的可能性较小。内存读取的频率也会影响延迟。另一个影响因素是由‘’if“语句和循环引起的动态分支。在着色器程序中遇到"if"语句，如果所有线程都求值并采用同一分支，则warp可以继续不需要考虑其他分支。然而如果一些甚至只有一个线程选择另一条路径，那么warp必须执行两个分支，丢弃每个特定线程中不需要的结果。这个问题称为线程发散，其中一些线程可能需要执行循环迭代，或者执行warp中的其他线程没有执行的“if”路径，而其他线程在此期间处于空闲状态。

![\img\in-post\rtr3\3-1](\img\in-post\rtr3\3-1.jpg)

原书图3.1，简化着色器执行示例。三角形的每个片元都是一个线程，组成了warp。每个warp简化显示为4个线程，实际上有32个线程。着色器程序有5条指令。四组GPU着色器处理器执行这些指令的第一个warp，直到“txr”命令检测到需要时间来获取它数据的情况。第二个warp是交换进来的着色程序的前三条指令，执行直到再次检测到停滞为止。在第三个warp交换并停滞后，交换到第一个warp并继续执行。如果此时它的“txr”命令的数据还没有返回，那么执行将真正停止，直到数据可用为止。每个warp依次完成。

### GPU渲染管线概述

![\img\in-post\rtr3\3-2](\img\in-post\rtr3\3-2.jpg)

原书图3.2，GPU渲染管线的实现。绿色阶段是完全可编程的，虚线表示为可选阶段。黄色阶段是可配置的，但是不可编程，例如各种混合模式可以在合并阶段设置。蓝色的阶段是完全固定的。

- GPU实现了第二章所描述的几何处理、光栅化、像素处理流水线。这些被划分为几个硬件阶段，具有不同程度的可操作性或可编程性（如图3.2所示）。注意这些物理阶段的划分与第二章中介绍的功能阶段有所不同。

- 这里描述的是逻辑模型，通过API程序暴露出来。这个逻辑管线的实现取决于硬件供应商。逻辑模型可以帮助你推断性能的影响因素，但不应该将其误认为GPU实际实现管线的方式。

- 顶点着色器是一个完全可编程的阶段，用于实现几何处理阶段。几何着色器是一个完全可编程的阶段，操作点、线或三角形上的顶点。它可以用于执行每个图元的着色操作，销毁图元或创建新图元。细分阶段和几何着色器是可选的，并不是所有GPU都支持它们，特别是在移动设备上。

### 可编程着色阶段

- 现代着色器程序使用统一的着色器设计。这意味着顶点、像素、几何和细分相关的着色器共享一个公共的编程模型。它们具有相同的指令集体系结构(instruction set architecture，ISA)。在DirectX中，实现该模型的处理器称为共着色器内核，具有这种内核的GPU具有统一的着色器体系结构。GPU可以根据自己的需要分配这些处理器，决定如何平衡负载。

- 着色器使用类c语言编程，比如DirectX使用HLSL(High-Level Shading Language),OpenGL使用GLSL(OpenGL Shading Language)。HLSL可以编译成汇编语言，也称为中间语言(intermediate language，IL)，以提供硬件独立性。

- 32位单精度浮点的标量和矢量是其基本数据类型，之后也支持32位整型和64位浮点型。浮点向量通常包含位置(xyzw)、法线、矩阵、颜色(rgba)或纹理坐标(uvwq)等数据。整数通常用于表示计数器、索引或位掩码。还支持综合数据类型，如结构体、数组和矩阵。

- 一个Draw Call会调用图形API来绘制一组图元，从而使图形管线执行并运行着色器。每个可编程着色阶段都有两种类型的输入：uniform 输入，值在一个draw call期间保持不变（但是可以在draw call间进行更改）；varying 输入，数据来自三角形的顶点或者光栅化阶段。例如像素着色器可以提供一个光源的颜色作为一个uniform值，三角形表面的位置随着像素的变化而变化（varying）。纹理是一种特殊的uniform输入，它曾经是应用于表面的彩色图像，但是现在可以看作是任何存储大量数据的数组。

### 可编程着色和API的发展

### 顶点着色器

### 细分阶段

### 几何着色器

### 像素着色器

### 合并阶段

### 计算着色器
