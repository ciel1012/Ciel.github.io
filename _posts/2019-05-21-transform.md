---
layout:     post
title:      "Transforms"
subtitle:   "\"《Real-Time Rendering 4th》笔记——第四章 转换\""
date:       2019-05-21
author:     "Ciel"
header-img: "img/post-bg-rtr.jpg"
mathjax: true
tags:
    - Real-Time Rendering
    - 笔记
---

# Transforms

> 本章介绍了转换的基本知识，这是处理几何图形的基本工具。从基本的仿射变换开始，还讨论了矩阵、四元数、顶点混合、变形和投影矩阵。理解这些，有助于辨别如何处理计算，提高代码效率。本章涉及许多线性代数相关内容。

1. [Basic Transforms 基础转换](#基础转换)

2. [Special Matrix Transforms and Operations 特殊矩阵变换和运算](#特殊矩阵变换和运算)

3. [Quaternions 四元数](#四元数)

4. [Vertex Blending 顶点混合](#顶点混合)

5. [Morphing 变形](#变形)

6. [Geometry Cache Playback 几何缓存回放](#几何缓存回放)

7. [Projection 投影](#投影)

### 基础转换

- 线性变换是一种保留向量加法和标量乘法的变换。满足以下公式：

![\img\in-post\rtr4\e1](\img\in-post\rtr4\e1.jpg)

- 使用齐次表示法，方向向量表示为$v = (v_x,v_y,v_z,0)$,点表示为$v = (v_x,v_y,v_z,1)$。

- 所有平移、旋转、缩放、反射和剪切矩阵都是仿射矩阵（affine）。仿射矩阵的主要特征是它保持了直线的并行性，但长度和角度不一定。仿射变换也可以是单个仿射变换的任意序列。

- 正交矩阵的逆就是其转置矩阵。

![\img\in-post\rtr4\t1](\img\in-post\rtr4\t1.jpg)

表4.1，本章讨论的大多数转换的摘要。

#### 4.1.1 Translation 平移

- 从一个位置到另一个位置的变化用一个平移矩阵T表示。这个矩阵用一个向量$t = (t_x, t_y, t_z)$来转换一个实体。

![\img\in-post\rtr4\e2](\img\in-post\rtr4\e2.jpg)

- 如下图，给出了一个平移变换例子。注意，方向向量$v = (v_x,v_y,v_z,0)$不受乘以T的影响，因为方向向量不能被平移。相反，点和向量都受到其余仿射变换的影响。平移矩阵的逆矩阵 $T^1(t)=T(-t)$ ，也就是说向量**t**是负的。

![\img\in-post\rtr4\4-1](\img\in-post\rtr4\4-1.jpg)

原书图4.1，左边的正方形用一个平移矩阵T(5,2,0)进行变换，其中正方形向右移动5个距离单位，向上移动2个距离单位。

- 有时在计算机图形学中看到，使用矩阵中平移向量在底部行，例如DirectX使用这种形式。在这种方案中，应用程序将从左到右读取矩阵。这样的向量和矩阵被称为行主形式，因为这些向量是行向量。在这本书中，使用了列主形式。无论使用哪一种，都是纯粹的符号分歧，当矩阵存储在内存中时，这16个值的后4个值是三个平移值，后面跟着一个1。

#### 4.1.2 Rotation 旋转

- 旋转变换使矢量围绕经过原点的给定轴旋转给定的角度。是一个刚体变换（保留了变换后点的间距，也不会导致左右交换）。方向矩阵是与摄像机视图或对象相关联的旋转矩阵，定义其在空间中的方向，即其向上和向前的方向。

- 二维空间旋转矩阵推导：参数化一个向量$v=(v_x,v_y)=(rcos\theta,rsin\theta)$。如果我们逆时针旋转弧度$\phi$，会得到$u=(rcos(\theta+\phi),rsin(\theta+\phi))$。可以推导出以下公式：

![\img\in-post\rtr4\e3](\img\in-post\rtr4\e3.jpg)

- 三维空间旋转矩阵为以下公式，分别绕x,y,z轴旋转$\phi$：

![\img\in-post\rtr4\e4](\img\in-post\rtr4\e4.jpg)

- 如果从4X4矩阵中删除最下面一行和最右边的列，就得到一个3X3矩阵。对于每一个3X3旋转矩阵R，它围绕任意轴旋转弧度$\phi$，轨迹(矩阵中对角线元素的和)是独立于轴的常数，公式为：

![\img\in-post\rtr4\e5](\img\in-post\rtr4\e5.jpg)

- 所有旋转矩阵的行列式都是1并且是正交的。这也适用于任意数量的这些转换的连接。还可以这样求矩阵倒数:$R_i^{-1}(\phi)=R_i(-\phi)$，即沿同一轴反向旋转。

- 例如图4.2，假设让一个物体绕z轴旋转弧度$\phi$，旋转中心是某个点p。由于绕点旋转的特征是点本身受到旋转影响，所以转换从平移对象开始，使点p与原点重合，通过$T(-p)$完成。之后是实际的旋转：$R_z(\phi)$。最后使用$T(p)$将对象转换回原来的位置。得到的变换X为：

![\img\in-post\rtr4\e6](\img\in-post\rtr4\e6.jpg)

注意上面的旋转顺序

![\img\in-post\rtr4\4-2](\img\in-post\rtr4\4-2.jpg)

#### 4.1.3 Scaling 缩放

- 一个缩放矩阵$S(s)=S(s_x,s_y,s_z)$在x,y,z方向上分别用因子$s_x,s_y,s_z$来缩放对象。任一分量为1则表示不缩放。如果$s_x=s_y=s_z$则是均匀缩放，否则称为非均匀缩放操作。有时用各向同性缩放和各向异性缩放来代替均匀和非均匀。逆矩阵$S^{-1}(s)=S(1/s_x,1/s_y,1/s_z)$。

![\img\in-post\rtr4\e7](\img\in-post\rtr4\e7.jpg)

- 另一种创建均匀缩放矩阵的有效方法是通过使用齐次坐标，操作位置(3,3)处的矩阵元素，即右下角的元素。执行此操作的两个不同矩阵如下所示，与使用S进行均匀缩放相反，使用S’必须始终进行均匀化。这可能是低效的，因为它涉及均匀化过程中的除法; 如果右下角的元素为1，则不需要除法。当然，如果系统总是在没有测试是否是1的情况下进行这种操作，那么就没有额外的成本。

![\img\in-post\rtr4\e8](\img\in-post\rtr4\e8.jpg)

- s的一个或三个分量上是负值给出了一种反射矩阵，也称为镜像矩阵。如果只有两个比例因子是-1，那么我们将旋转弧度$\pi$。需要注意的是，一个旋转矩阵与一个反变换矩阵连接也是一个反变换矩阵。因此，下面是一个反射矩阵:

![\img\in-post\rtr4\e9](\img\in-post\rtr4\e9.jpg)

检测到反射矩阵时，通常需要特殊处理。例如，一个顶点按逆时针顺序排列的三角形在被一个反射矩阵变换时将得到一个顺时针顺序。这一顺序的改变可能导致不正确的照明和背面剔除发生。为了检测一个给定的矩阵是否以某种方式反射，计算矩阵左上3X3个元素的行列式。如果值是负数，则矩阵是反射的。例如，方程4.12中矩阵的行列式是$0\cdot0-(-1)\cdot(-1)=-1$

- 缩放矩阵S只沿x轴、y轴和z轴缩放。如果要在其他方向进行缩放，则需要进行复合变换。假设缩放应该沿着标准正交、右手向量fx、fy和fz的轴进行。首先，构造矩阵F，改变基底，如下所示：

![\img\in-post\rtr4\e10](\img\in-post\rtr4\e10.jpg)

其思想是使三个坐标轴给出的坐标系与标准坐标轴重合，然后利用标准缩放矩阵，再进行变换。第一步是乘以F的转置，然后做实际的缩放，再返回一个变换。变换公式为$X=FS(s)F^T$。

#### 4.1.4 Shearing 剪切

- 剪切矩阵可以在游戏中用于扭曲整个场景以创建迷幻效果，或者扭曲模型的外观。有六个基本的剪切矩阵，分别表示为$H_{xy}(s),H_{xz}(s),H_{yx}(s),H_{yz}(s),H_{zx}(s),H_{zy}(s)$,第一个下标用来表示哪个坐标被剪切矩阵改变了,第二个下标表示进行剪切的坐标。

![\img\in-post\rtr4\4-3](\img\in-post\rtr4\4-3.jpg)

原书图4.3，用$H_{xz}(s)$剪切单位正方形的效果。y值和z值都被转换所影响，而x值是旧的x值和s乘以z值的和，导致正方形倾斜。这种转换是保留面积的，可以看到虚线区域相同。

- 下标可以用来求参数s在矩阵中的位置。如图xz代表第一行第三列：

![\img\in-post\rtr4\e11](\img\in-post\rtr4\e11.jpg)

将这个矩阵与点p相乘得到一个点$(p_x+sp_z\ \ p_y\ \ p_z)^T$。从图形上看，图4.3中的单位正方形显示了这一点。$H_{ij}(s)$的逆(第i个坐标相对于第j个坐标进行剪切，其中i ≠ j)是通过反向剪切得到的，即$H_{ij}^{-1}(s)=H_{ij}(-s)$。

- 可以使用稍微不同的剪切矩阵

![\img\in-post\rtr4\e12](\img\in-post\rtr4\e12.jpg)

然而，在这里，这两个下标都用来表示这些坐标将被第三个坐标剪切。这两种不同的描述之间的联系是$H_{ij}^{'}(s,t)=H_{ik}(s)H_{jk}(s)$，其中k用作第三个坐标的索引。需要注意的是，由于任意剪切矩阵\|H\|= 1，这是一个保持体积的变换，如图4.3所示。

![\img\in-post\rtr4\4-4](\img\in-post\rtr4\4-4.jpg)

原书图4.4，说明矩阵相乘时的顺序依赖性。在第一行中，应用旋转矩阵$R_z(\pi/6)$，然后缩放$S(s)$，其中S = (2,0.5,1).则复合矩阵为$S(s)R_z(\pi/6)$。在下一行，矩阵按相反的顺序应用，得到$R_z(\pi/6)S(s)$。结果明显不同。一般认为，对于任意矩阵M和N, MN ≠ NM。

#### 4.1.5 Concatenation of Transforms 变换的连接

- 由于矩阵乘法运算的不可交换性，矩阵出现的顺序很重要。因此，变换的连接被称为顺序相关的。

- 将一系列矩阵连接成一个矩阵的明显原因是为了获得效率。例如，假设你有一个拥有数百万个顶点的游戏场景，并且场景中的所有对象都必须缩放、旋转和最终平移。现在，不是将所有顶点与三个矩阵相乘，而是将三个矩阵连接成一个矩阵。然后将这个矩阵应用于顶点。这个复合矩阵是C = TRS。注意这里的顺序。缩放矩阵S应该首先应用于顶点，因此在合成中出现在右边。这个顺序意味着TRSp = (T(R(Sp))，其中p是要转换的点。TRS是场景图系统常用的顺序。

- 值得注意的是，虽然矩阵连接是顺序相关的，但可以按需要对矩阵进行分组。例如，假设您想用TRSp计算一次刚体运动变换TR。将这两个矩阵(TR)(Sp)组合在一起并用中间结果替换是有效的。因此，矩阵连接是关联的。

#### 4.1.6 The Rigid-Body Transform 刚体变换

### 特殊矩阵变换和运算

### 四元数

### 顶点混合

### 变形

### 几何缓存回放

### 投影
