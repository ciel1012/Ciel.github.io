---
layout:     post
title:      "Shading Basics"
subtitle:   "\"《Real-Time Rendering 4th》笔记——第五章 着色基础知识\""
date:       2019-07-07
author:     "Ciel"
header-img: "img/post-bg-rtr.jpg"
catalog: true
mathjax: true
tags:
    - Real-Time Rendering
---

# Shading Basics

> 本章讨论着色基础，同时适用于真实化与风格化渲染。（本书9-14章主要讨论真实感渲染，15章则是风格化渲染）

渲染三维物体的图像时，模型不仅要有合适的几何形状，还要有理想的视觉表现。根据应用程序的不同，可以从真实感到出于创造性原因而选择的各种风格化表现。

![\img\in-post\rtr5\5-1](\img\in-post\rtr5\5-1.jpg)

原书图5.1，上图是使用虚幻引擎渲染的真实景观场景。下图来自Campo Santo的游戏《Firewatch》，该游戏采用了富有特点的艺术风格。

### 1着色模型

确定呈现对象外观的第一步是选择一个着色模型，来描述对象的颜色应该如何根据表面方向、视图方向和光照等因素而变化。

- 例如，使用Gooch着色模型的一个变体。这是非真实感渲染的一种形式，是为了增加技术插图中细节的可读性。Gooch着色背后的基本思想是将表面法线与光的位置进行比较。如果法线指向光，则用较暖的色调给表面上色;如果它指向别处，则使用较冷的色调。两者之间的角度在这些色调之间进行插值，这些色调基于用户提供的表面颜色。在本例中，我们为模型添加了一个风格化的“高亮”效果，以使表面具有闪亮的外观。着色模型通常具有用于控制外观变化的属性。设置这些属性的值是确定对象外观的下一步。示例模型只有一个表面颜色属性，如图5.2的底部图像所示：

![\img\in-post\rtr5\5-2](\img\in-post\rtr5\5-2.jpg)

原书图5.2，一个风格化的着色模型结合Gooch着色和高光效果。上图显示了一个表面颜色为中性的复杂物体。下图显示了不同表面颜色的球体。

- 像大多数着色模型一样，这个例子是由相对于视图和光照方向的表面方向来反映的。为便于着色，这些方向通常表示为标准化(单位长度)向量，如下所示：

![\img\in-post\rtr5\5-3](\img\in-post\rtr5\5-3.jpg)

原书图5.3，示例着色模型的单位长度向量输入:表面法线n、视图向量v和光方向l。

- 确定了着色模型的所有输入，可以查看模型本身的数学定义：

![\img\in-post\rtr5\e1](\img\in-post\rtr5\e1.jpg)

这个方程使用了以下中间计算：

![\img\in-post\rtr5\e2](\img\in-post\rtr5\e2.jpg)

此定义中的一些数学表达式也经常出现在其他着色模型中。clamping操作（通常限制到0或限制在0和1之间）在着色中很常见。这里使用了$x^{\mp}$表示clamping操作，限制s在0-1。点积出现三次，每次出现在两个单位长度向量之间，两个向量的点积是它们的长度和夹角余弦的乘积。因此，两个单位长度向量的点积只是余弦，它比较两个向量彼此对齐程度的有用量度。在着色中，由余弦组成的简单函数通常是描述两个方向(例如光的方向和表面法线)之间关系最简单准确的数学表达式。

- 另一个常用的着色操作是基于0到1之间的标量值在两种颜色之间进行线性插值。该操作的形式为$tc_a+(1-t)c_b$，当t的值分别在1和0之间移动时，在ca和cb之间插值。该式在着色模型中出现两次，第一次是在$c_{warm}$和$c_{cool}$之间进行插值，第二次是在之前的插值结果和$c_{highlight}$之间进行插值。线性插值在着色器中经常出现，它是一个内置函数，称为lerp或mix，在我们所见过的每种着色语言中都是如此。

- $r=2(n\cdot l)n-l$计算出了反射光向量，它将l映射到n上。虽然不像前两个操作那么常见，但对于大多数着色语言来说很常用，可以使用内置的反射(reflect)函数。

- 通过以不同方式将这些操作与各种数学表达式和着色参数组合，可以为各种风格化和逼真的表现定义着色模型。

### 2光源

光照为着色提供了一个主导方向。可以有多个光源，每个光源都有自己的大小、形状、颜色和强度;间接照明增加了更多的变化。我们将在第9章中看到，基于物理的、逼真的光照模型需要考虑所有这些参数。

相反，根据应用程序的需要和视觉风格，风格化的着色模型可以以许多不同的方式使用光照。一些高度程式化的模型可能根本没有灯光的概念，或者(像Gooch着色示例)可能只使用它来提供一些简单的方向性。

- 光照复杂性的下一步是让着色模型以二分的方式对光的存在或不存在做出反应。用这种着色模型表面在受光和不受光时有不同表现。这意味着区分这两种情况与这些因素有关:与光源的距离、阴影(这将在第7章讨论)、表面是否朝向光源(即表面法线n与光方向l之间的夹角大于90)，或这些因素的某些组合。

- 这可以表示为一个简单的插值，可能是0到1的有限范围。或者作为一个无界限的量，以另一种方式着色。后者的一个常见选择是将阴影模型分解为光照和非光照部分，光照强度$k_{light}$线性缩放光照部分:

![\img\in-post\rtr5\e3](\img\in-post\rtr5\e3.jpg)

- 非光照部分funlit(n,v)对应于将光视为二分的着色模型的“不受光影响时的外观”。根据所需的视觉风格和应用程序的需要，它可以有多种形式。例如，funlit() = (0,0,0)将使任何受到光源照射的表面变成纯黑色。另外，非光照部分可以表示某种形式的风格化外观，类似于Gooch模型为背向光的表面使用的冷色。通常，着色模型的这一部分表示某种形式的照明，其不直接来自明确放置的光源，例如来自天空的光或来自周围物体的光。这些其他形式的照明将在第10章和第11章中讨论。

- 我们之前提到过，光源不影响表面光的方向l大于表面法线n90度的点（实际来自表面下方）。这可以被认为是光相对于表面的方向及其对着色一般影响的一个特例。虽然是基于物理的，但这种关系可以从简单的几何原理推导出来，并且对于许多类型的非基于物理的、风格化的着色模型也是有用的。

![\img\in-post\rtr5\5-4](\img\in-post\rtr5\5-4.jpg)

原书图5.4，上图显示了光在表面上的横截面图。在左边，光线直接照射到表面上；在中间，它们以一个角度照射到表面上；在右边，我们看到使用向量点积来计算角度余弦。下图显示了横切面(包括光和视图向量)与整个表面的关系。

- 光在表面上的反射可以被可视化为一组光线，光线的密度与照射到表面的光强相对应，用于表面着色。光线沿横截面照射到表面的距离与l和n夹角的余弦成反比。所以，入射到表面的光线的总密度与l和n夹角的余弦成正比，正如我们之前看到的，它等于这两个单位长度向量的点积。在这里可以看到，**l与光实际入射方向相反**，但这样方便计算因此做点积前取光照方向的反向量。
- 更精确地说，当点积为正时，光线密度(以及光线对阴影的贡献)与点积成正比。负值对应于从表面后面射来的光线，这些光线没有相互作用。所以在乘以光的点积之前需要先把**点积限制到0以上**。使用$x^+$符号表示将负值保持为零：

![\img\in-post\rtr5\e4](\img\in-post\rtr5\e4.jpg)

- 支持多个光源的着色模型通常使用公式5.5的结构，或者基于物理模型的公式5.6。这对于风格化的模型也是有好处的，因为它有助于确保整体的一致性，特别是对那些背对光线或处于阴影的表面。然而，一些模型并不适合这种结构，这种模型将使用公式5.5中的结构。

- 函数flit()最简单的选择可能是将其设置为常量颜色，$f_{lit}()=c_{surface}$，得到如下着色模型：

![\img\in-post\rtr5\e5](\img\in-post\rtr5\e5.jpg)

- 这个发光部分对应Lambert光照模型。该模型适用于理想的反射面，即表面完全哑光。这里对Lambert模型做了一个稍微简化的解释，将在第9章进行更严格的讨论。Lambertian模型本身可用于简单的着色，是许多着色模型的关键组成部分。

- 从方程5.3-5.6可以看出，光源通过两个参数与着色模型相互作用：指向光的向量l和光源颜色$c_{light}$。 存在各种不同类型的光源，这主要取决于这两个参数在场景中如何变化。

- 接下来将讨论几种常见的光源，它们有一个共同点:在给定的表面位置，每个光源只从一个方向l照射表面。换句话说，光源从表面位置看是一个极小的点。这对于真实世界的光来说并不完全正确，但是大多数光源相对于它们与被照明表面的距离来说都很小，使得这是一个合理的近似。在第7.1.2节和第10.1节中，我们将讨论从一系列方向照亮表面位置的光源，即区域灯光(area light)。

#### 2.1方向光

- 定向光(Directional light)是最简单的光源模型。l和$c_{light}$在场景中都是常量，只是$c_{light}$可能会被阴影减弱。定向光没有位置属性。当然，实际光源在空间中确实有特定的位置。定向光是抽象，它适用于当光源距离相对于场景大小较大时。比如远距离灯光，几乎所有被太阳照亮的场景。
- 方向光的概念可以稍微扩展，允许改变$c_{light}$的值，而光的方向l保持不变。这通常是为了表现特殊场景。例如,可以定义一个区域有两个嵌套的盒子,$c_{light}$在外框是纯黑色(0,0,0),在内框等于一个常数,并在两个盒子之间的区域进行插值。

#### 2.2精确光

精确光(punctual light)不是指准时赴约的灯，而是一种有位置的灯，不像方向灯。这些光也没有尺寸，没有形状或大小，不像真实的光源。我们使用“punctual”这个术语，来自拉丁语，意思是“点”，指的是由一个单一的局部位置产生的所有光源组成的类。我们用“point light”这个术语来表示一种特殊的发射器，它在所有方向上都发出同样的光。所以，点光源和聚光灯是两种不同形式的精确光。光方向向量l变化取决于当前着色表面点$p_0$相对于精确光位置：$l=\frac{p_{light}-p_0}{\| p_{light}-p_0 \|}\qquad$.

这个方程是向量归一化的一个例子:用一个向量除以它的长度，得到一个指向相同方向的单位长度向量。这是另一种常见的着色操作，与我们在前一节中看到的着色操作一样，它是大多数着色语言中的内置函数。然而，有时需要此操作的中间结果，这需要在多个步骤中使用更基本的操作显式地执行规范化。将其应用于精确光方向计算，得到如下结果：

![\img\in-post\rtr5\e6](\img\in-post\rtr5\e6.jpg)

我们需要的中间值是r，即精确光源和当前着色点之间的距离。除了对光向量进行归一化外，还需要用r值作为距离计算光色$c_{light}$衰减(变暗)的函数。这将在下一节中进一步讨论。

**点/泛光（Point/Omni Lights）**

- 在所有方向上均匀发光的精确光被称为点光或泛光。对于点光源，$c_{light}$的变化是距离r的函数，变化的唯一来源是上面提到的距离衰减。图5.5显示了为什么会出现这种变暗，使用类似的几何推理来演示图5.4中的余弦因子。在给定的表面上，点光源的光线间距与表面到光线的距离成正比。与图5.4中的余弦因子不同，这种间距的增加沿着曲面的两个维度进行，因此光线密度($c_{light}$)与平方距离倒数$1/r^2$成正比。这使我们能够使用单个光属性$c_{light0}$指定$c_{light}$中的空间变化，$c_{light0}$定义为固定参考距离$r_0$处的$c_{light}$值：

![\img\in-post\rtr5\e7](\img\in-post\rtr5\e7.jpg)

- 式5.11常称为反平方衰减。虽然从技术上讲，点光源的距离衰减是正确的，但是有一些问题使得这个方程对于实际的着色使用不是很理想。第一个问题发生在相对较小的距离。当r趋于0时，$c_{light}$的值将以无界的方式增加。当r达到0时，我们会得到一个被0整除的奇点。为了解决这个问题，一个常见的修改方法是在分母上加一个小值$\epsilon$，如式5.12。$\epsilon$的确切值取决于应用程序;例如，虚幻游戏引擎使用$\epsilon =1$ cm。CryEngine和Frostbite游戏中使用替代方法是把r限制在最小值$r_{min}$之间，如式5.13。与前一种方法中使用的任意值$\epsilon$不同，$r_{min}$的值有一个物理解释:发出光的物理对象的半径。r小于$r_{min}$的值对应于穿透物理光源内部表面，这是不可能的。

![\img\in-post\rtr5\5-5](\img\in-post\rtr5\5-5.jpg)

原书图5.5，点光源的光线间距与距离r成比例增加。由于间距增加发生在二维空间，光线密度(光强)成比例减少到$1/r^2$。

- 相反，反平方衰减的第二个问题发生在相对距离较大时。问题不在于视觉效果，而在于性能。尽管光强随着距离的增加而减小，但它从不等于0。为了有效渲染，希望光在某些有限距离处达到0强度（第20章）。有许多不同的方法修改反平方方程来实现这一点。 理想情况下，修改应尽可能少。为了避免光在边界处出现明显截止，最好同样距离下修正函数的导数和值达到0。一种解决方案是将反平方方程乘以具有所需属性的窗口函数。虚幻引擎和寒霜引擎都使用这样的方法:

![\img\in-post\rtr5\e8](\img\in-post\rtr5\e8.jpg)

+2表示在平方之前将值(如果是负数)固定为0。图5.6给出了一个反平方曲线的例子，即式5.14中的窗口函数，以及两者相乘的结果。

![\img\in-post\rtr5\5-6](\img\in-post\rtr5\5-6.jpg)

原书图5.6，该图显示了一个反平方曲线（使用$\epsilon$方法避免奇点，$\epsilon$值为1），如式5.14所示的窗口函数（$r_{max}$设置为3）和窗口曲线。

- 应用需求将影响所使用方法的选择。例如，当距离衰减函数以相对较低的空间频率采样时(例如在光映射或每个顶点中)，$r_{max}$处的导数为0就显得尤为重要。CryEngine不使用光映射或顶点光照，因此它采用了更简单的调整，切换到0.8$r_{max}$和$r_{max}$之间的线性衰减。

- 对于某些应用程序，匹配反平方曲线不是优先的，因此可以使用其他函数。这有效地将方程5.11-5.14推广到下面：$c_{light}(r)=c_{light0}f_{dist}(r)$，其中$f_{dist}(r)$是距离的函数。这样的函数称为距离衰减函数。在某些情况下，使用平方衰减函数是有性能约束的。例如，游戏《Just Cause 2》需要非常便宜的灯光计算。这就需要一个易于计算的衰减函数,同时也足够平滑，以避免每个顶点的光照伪像。

![\img\in-post\rtr5\e9](\img\in-post\rtr5\e9.jpg)

- 在其他情况下，衰减函数的选择可能是出于创造性的考虑。例如，虚幻引擎，对于现实和风格化的游戏，有两种模式的光衰减:一个反平方模式，如公式5.12所述，和指数衰减模式，可以调整以创建各种衰减曲线。游戏《古墓丽影》(2013)的开发者使用样条编辑工具来绘制衰减曲线，从而能够更好地控制曲线形状。

**聚光灯（Spotlights）**

- 与点光源不同的是，几乎所有真实光源的照明都随方向和距离而变化。这种变化可以表示为一个方向衰减函数$f_{dir}(r)$与距离衰减函数相结合，以定义光强度的整体空间变化：$c_{light}= c_{light0}f_{dist}(r)f_{dir}(l)$.

- $f_{dir}(l)$的不同选择可以产生不同的照明效果。其中一个重要的类型是聚光灯，它把光投射在一个圆锥体上。聚光方向衰减函数围绕聚光方向矢量s具有旋转对称性，可以表示为s到表面的反向光向量-l的夹角$\theta_s$函数。光向量需要反转，定义为一个指向光的向量。

- 大多数聚光灯函数使用$\theta_s$的cos组成的表达式。聚光灯通常有一个阴影角(umbra angle)$\theta_u$，限制光对于所有的$\theta_s \ge \theta_u,f_{dir}(l)=0$。这个角度可以用与前面看到的最大衰减距离$r_{max}$类似的方式进行剔除。聚光灯通常还有一个半影角$\theta_p$(penumbra angle)，它定义了一个内锥，在那里光强度满值。

![\img\in-post\rtr5\5-7](\img\in-post\rtr5\5-7.jpg)

原书图5.7，聚光灯:$\theta_s$是从光的定义方向s到-l即到表面方向的角度;$\theta_p$表示半影角;$\theta_u$表示本影角。

- 各种方向衰减函数用于聚光灯，但它们往往大致相似。例如，函数$f_{dirF}(l)$用于Frostbite游戏引擎，函数$f_{dirT}(l)$用于three.js浏览器图形库：

![\img\in-post\rtr5\e10](\img\in-post\rtr5\e10.jpg)

$x^{\mp}$是clamp操作，限制x在0-1之间。smoothstep函数是一种三次多项式，常用于平滑插值。它是大多数着色语言的内置函数。

![\img\in-post\rtr5\5-8](\img\in-post\rtr5\5-8.jpg)

原书图5-8，一些类型的灯。从左到右:定向，没有衰减的点光，平滑的聚光灯。请注意，由于光线与表面之间的角度变化，点光源照射边缘会暗一些。

**其他精确光**

精确光的$c_{light}$值还有许多其他的变化方式。

$f_{dir}(l)$函数不限于上面讨论的简单聚光灯衰减函数;它可以表示任何类型的方向变化，包括从真实光源测量的复杂模式。IES(The Illuminating Engineering Society)为这样的测量定义了标准文件格式，并在许多游戏或引擎中应用。

游戏《古墓丽影》(2013)有一种点状光，它在x轴、y轴和z轴上应用了独立的衰减函数。在《古墓丽影》中，曲线也可以用来随着时间的推移改变光的强度，例如，产生一个刺眼的火炬。

在6.9节中，我们将讨论如何通过使用纹理来改变光的强度和颜色。

#### 2.3其他光源类型

方向光和精确光的主要特征是光的方向l的计算方法。不同类型的光可以通过使用其他方法来计算光的方向来定义。例如，除了前面提到的光类型，《古墓丽影》也有使用线段而不是点作为光源的胶囊灯。对于每个像素，以线段上最近点的方向作为光的方向l。

只要着色器有l和$c_{light}$用于计算着色方程，任何方法都可以用来计算这些值。

到目前为止讨论的光的类型都是抽象的。实际上，光源有大小和形状，它们从多个方向照亮表面的点。在渲染中，这样的光被称为区域光(area lights)，它们在实时应用中的使用正在稳步增加。区域光渲染技术分为两类:一类是模拟区域光部分遮挡导致阴影边缘软化的技术(第7.1.2节)，另一类是模拟区域光对表面着色影响的技术(第10.1节)。第二种类型的照明最明显的是光滑的镜面，在那里，光的形状和大小可以通过反射清晰地辨别出来。方向光和精确光不太可能被废弃，尽管它们不再像过去那样无处不在。计算光面积的近似方法已经开发出来，而且实现起来相对便宜，因此得到了更广泛的应用。GPU性能的提高也允许比过去更精确的技术。

### 3实现着色模型

本节将讨论设计和编写着色实现的一些关键考虑事项，还将介绍一个简单的实现示例。

#### 3.1评估频率

- 在设计着色实现时，需要根据计算的频率来划分计算。首先，确定给定计算的结果在整个draw call中是否总是常量。在这种情况下，计算可以由应用程序执行，通常在CPU上执行，不过可以使用GPU计算着色器进行特别昂贵的计算。计算结果通过统一(uniform)着色器输入传递给图形API。

- 即使在这一类别中，也有很多可能的评估频率。 最简单的情况是着色方程中的常量子表达式，但这也适用于任何基于很少变化的因素的计算，比如硬件配置和安装选项。在编译着色器时，这种着色计算甚至不需要设置统一的着色器输入。或者可以在安装时或加载应用程序时以离线预计算方式执行计算。

- 另一种情况是，着色计算的结果在应用程序运行过程中发生变化，但是变化非常缓慢，没有必要每帧都更新它。例如，在虚拟游戏世界中依赖于一天中时间的光照因素。如果计算很昂贵，那么将其分摊到多个帧可能是值得的。

- 其他情况包括每帧执行一次计算，如连接视图和透视图矩阵;或每个模型更新一次，如根据位置更新模型光照参数;或者每次绘制调用一次，例如，更新模型中每个材料的参数。按评估频率对统一着色器输入进行分组对于应用程序效率很有用，并且还可以通过最小化不断更新来帮助提高GPU性能。

- 如果着色计算的结果在绘制调用中发生更改，则不能通过统一的着色器输入将其传递给着色器。相反，它必须由第3章中描述的可编程着色器阶段之一计算，如果需要，通过不同的着色器输入传递到其他阶段。理论上，着色计算可以在任何可编程阶段执行，每个阶段对应一个不同的评估频率:

  - 顶点着色器(Vertex shader) - 评估每个细分前顶点

  - 外壳着色器(Hull shader)——评估每个表面补丁

  - 域着色器(Domain shader)——评估每个细分后顶点

  - 几何着色器(Geometry shader)——评估每个片元

  - 像素着色器(Pixel shader)——评估每个像素

- 实际上，大多数着色计算是按像素执行的。虽然这些通常在像素着色器中实现，但是计算着色器的实现越来越普遍;第20章将讨论几个例子。其他阶段主要用于几何运算，如变换和变形。为了理解为什么会这样，我们将比较每个顶点和每个像素着色计算的结果。在较早的文本中，它们有时分别被称为Gouraud shading和Phong shading，但这些术语在今天并不常用。这个对比使用的着色模型有点类似于公式5.1中的着色模型，但修改后可以使用多个光源。

- 图5.9显示了不同顶点密度模型的逐像素和逐顶点着色结果。对于龙来说，一个非常密集的网格，两者之间的差异很小。但是在茶壶上，顶点着色的计算会导致可见的错误，比如角度形状的高光，而在两个三角形的平面上，顶点着色的版本显然是不正确的。这些错误的原因是着色方程的某些部分，特别是高亮部分，其值在网格表面上是非线性变化的。这使得它们不适合顶点着色器，顶点着色器的结果在输入到像素着色器之前会在三角形上进行线性插值。

![\img\in-post\rtr5\5-9](\img\in-post\rtr5\5-9.jpg)

原书图5.9，为示例着色模型的逐像素和逐顶点计算的比较  

式5.19，三种不同的顶点密度模型上的表现。左列显示逐像素计算结果，中列显示逐顶点计算结果，右列显示每个模型的线框渲染图，以显示顶点密度。

- 原则上，可以在像素着色器中只计算着色模型的高光部分，然后在顶点着色器中计算其余部分。这可能不会产生可视化的伪影，而且理论上可以节省一些计算。实际上，这种混合实现通常不是最优的。着色模型的线性变化部分往往是计算成本最低的，以这种方式分割阴影计算往往会增加开销，比如重复计算和额外的变化输入，从而超过节省部分。

- 如前所述，在大多数实现中，顶点着色器负责非着色操作，如几何变换和变形。最终得到的几何表面属性，转换成适当的坐标系，由顶点着色器编写出来，在三角形上进行线性插值，并作为不同的着色器输入传递到像素着色器。这些属性通常包括曲面的位置、曲面法向量，如果需要进行法向映射，还可以选择曲面切向量。

- 注意，即使顶点着色器总是生成单位长度的曲面法线，插值也可以改变它们的长度。参见图5.10的左侧。因此，法线需要在像素着色器中重新规范化(缩放到长度1)。然而，顶点着色器生成法线的长度仍然很重要。如果法线长度在顶点之间有明显的变化，例如作为顶点混合的一个边，这将使插值偏移，如图5.10右侧。由于这两个影响，常常在插值前插值后进行规范化，即在顶点着色器和像素着色器中。

![\img\in-post\rtr5\5-10](\img\in-post\rtr5\5-10.jpg)

原书图5.10，在左边，我们看到单位法线在曲面上的线性插值得到长度小于1的插值向量。在右边，我们看到具有显著不同长度的法线的线性插值导致内插方向偏向两个法线中较长的那条。

- 与表面法线不同，指向特定位置的向量，如视图向量和用于精确光的向量，通常不进行插值。相反，插值表面位置用于在像素着色器中计算这些向量。除了我们已经看到的归一化(在任何情况下都需要在像素着色器中执行)之外，这些向量都是用向量减法计算的，这非常快。如果由于某种原因需要插值这些向量，请不要事先将它们标准化。 这将产生不正确的结果，如图5.11所示。

![\img\in-post\rtr5\5-11](\img\in-post\rtr5\5-11.jpg)

原书图5.11，两个光矢量之间的插值。在左边，插值前对它们进行归一化会导致插值后的方向不正确。在右边，插值非标准化向量会得到正确的结果。

- 前面我们提到过顶点着色器将曲面几何转换为适当的坐标系。相机和光的位置通过一致的变量传递给像素着色器，通常由应用程序转换为相同的坐标系。这将最小化像素着色器所做的工作，从而将所有的着色模型向量带入相同的坐标空间。但是哪个坐标系才是合适的呢?可能性包括全局世界空间以及摄像机的本地坐标系，或者更少见的是当前呈现模型的坐标系。通常根据系统的考虑(如性能、可实现性和简单性)为呈现系统整体做出选择。例如，如果渲染的场景需要包含大量的灯光，那么可以选择世界空间来避免改变灯光的位置。另外，相机空间可能是首选，以更好地优化与视图向量相关的像素着色器操作，并可能提高精度(第16.6节)。

- 尽管大多数着色器实现，包括我们将要讨论的示例实现，都遵循上面描述的一般大纲，但当然也有例外。例如，一些应用程序出于风格上的原因选择了每个图元着色的平面外观。这种样式通常称为flat shading。图5.12显示了两个示例。

![\img\in-post\rtr5\5-12](\img\in-post\rtr5\5-12.jpg)

原书图5.12，两款flat shading风格游戏《Kentucky Route Zero》和《That Dragon ，Cancer》。

- 原则上，平面着色可以在几何着色器中执行，但最近的实现通常使用顶点着色器。这是通过将每个图元的属性与其第一个顶点关联起来并禁用顶点值插值来实现的。禁用插值(可以对每个顶点值单独执行)将使第一个顶点的值传递给图元中的所有像素。

#### 3.2应用实例

现在我们将展示一个示例着色模型实现。如前所述，我们正在实现的着色模型类似于公式5.1中的扩展Gooch模型，但是经过了修改，可以处理多个光源：

![\img\in-post\rtr5\e11](\img\in-post\rtr5\e11.jpg)

进行以下中间计算:

![\img\in-post\rtr5\e12](\img\in-post\rtr5\e12.jpg)

这个公式适用于式5.6中的多光结构：

![\img\in-post\rtr5\e13](\img\in-post\rtr5\e13.jpg)

本例中的亮项和非亮项如下，通过调整冷色的非光照贡献，使结果看起来更像原始方程：

![\img\in-post\rtr5\e14](\img\in-post\rtr5\e14.jpg)

在大多数典型的渲染应用程序中，不同材质属性的值(如$c_{surface}$)将存储在顶点数据中，或者更常见是存储在纹理中(第6章)。然而，为了保持这个示例实现的简单性，我们将假设$c_{surface}$在整个模型中是常量。这个实现将使用着色器的动态分支功能在所有光源上进行循环。虽然这种直接的方法可以很好地用于相当简单的场景，但它不能很好地扩展到具有许多光源的大型和几何复杂的场景。为了简单起见，这里只支持一种光源：点光源。着色模型不是单独实现的，而是在更大的渲染框架中实现。这个例子是从“Phone-shaded Cube”WebGL2示例修改而来的，但同样的原则也适用于更复杂的框架。我们将讨论一些来自应用程序的GLSL着色器代码和JavaScript WebGL调用的示例。目的是为了展现一般的实现原则。我们将按照“由内到外”的顺序进行实现，首先是像素着色器，然后是顶点着色器，最后是应用程序端图形API调用。

着色器代码包含着色器输入和输出定义。正如前面3.3节所讨论的，使用GLSL着色器输入可以分为两类。一个是一组统一的输入，这些输入的值由应用程序设置，并且在draw call期间保持不变。第二种类型由不同的输入组成，这些输入的值可以在着色器调用(像素或顶点)之间更改。像素着色器的不同输入输出在GLSL中标记如下：

```glsl
in vec3 vPos;
in vec3 vNormal;
out vec4 outColor;
```

这个像素着色器只有一个最终颜色输出。像素着色器输入与顶点着色器输出相匹配，顶点着色器输出在输入像素着色器之前在三角形上进行插值。这个像素着色器有两个不同的输入:表面位置和表面法线，都在应用程序的世界空间坐标系中。uniform输入数量很多，所以为了简洁起见，这里只给出两个与光源有关的定义：

```glsl
struct Light {
    vec4 position;

    vec4 color;

};
uniform LightUBlock {
    Light uLights [MAXLIGHTS];

};
uniform uint uLightCount;
```

因为这些都是点光源，所以每个点的定义都包含一个位置和一个颜色。这些被定义为vec4而不是vec3，以符合GLSL std140数据标准。虽然因此可能会导致一点空间浪费，但它简化了确保CPU和GPU之间数据布局一致的任务，这也是本例中使用它的原因。Light结构数组定义在一个统一结构块中，这是一个GLSL特性，用于将一组统一变量绑定到一个缓冲区对象，以便更快地传输数据。数组长度定义为应用程序在单个draw call调用允许的最大灯光数。稍后我们将看到，应用程序在着色器编译之前用正确的值(本例中为10)替换着色器源中的MAXLIGHTS字符串。uniform整数uLightCount是绘制调用中激活灯光的实际数量。

接下来是像素着色器代码：

```glsl
vec3 lit( vec3 l, vec3 n, vec3 v) {
    vec3 r_l = reflect (-l, n);
    float s = clamp (100.0 * dot(r_l , v) - 97.0 , 0.0 , 1.0) ;
    vec3 highlightColor = vec3 (2 ,2 ,2);
    return mix( uWarmColor , highlightColor , s);
}
void main () {
    vec3 n = normalize ( vNormal );
    vec3 v = normalize ( uEyePosition .xyz - vPos );
    outColor = vec4 ( uFUnlit , 1.0) ;
    for ( uint i = 0u; i < uLightCount ; i++) {
        vec3 l = normalize ( uLights [i]. position .xyz - vPos );
        float NdL = clamp (dot(n, l), 0.0 , 1.0) ;
        outColor .rgb += NdL * uLights [i]. color .rgb * lit(l,n,v);
    }
}
```

我们为lit项定义了一个函数，它由main()函数调用。总的来说，这是方程5.20和5.21的一个简单的GLSL实现。注意，$f_{unlit}()$和$c_{warm}$的值作为统一变量传递。由于这些值在整个绘制调用期间都是常量，因此应用程序可以计算这些值，从而节省一些GPU周期。

这个像素着色器使用了几个内置GLSL函数。reflect()的作用是在第二个向量定义的平面上反射第一个向量，在本例中是反向光入射向量和曲面法向量。由于我们希望光向量和反射向量都指向原离表面的地方，所以在将其传递到reflect()前需要先对光向量进行反向。clamp()函数有三个输入，其中后两个参数定义了第一个输入被限制的范围。在大多数GPU上，限制在0-1之间的特殊情况（对应HLSL中的saturate()函数）是快速的，通常都无额外消耗。这就是在这里使用它的原因，尽管我们知道它不会超过1，只需要将值固定到0。mix()函数也有三个输入，并根据第三个值(一个介于0和1之间的混合参数)在其中的暖色和高光色之间进行线性插值。在HLSL中，这个函数称为lerp()。最后，normalize()将一个向量除以其长度，将其长度缩放为1。

现在让我们看看顶点着色器。由于我们已经看到了像素着色器的一些例子，所以我们不会展示它的任何一个uniform设计，但是不同的输入和输出设计是值得研究的:

```glsl
layout ( location =0) in vec4 position ;
layout ( location =1) in vec4 normal ;
out vec3 vPos ;
out vec3 vNormal ;
```

注意，如前所述，顶点着色器输出匹配像素着色器的不同输入。输入包括指定数据如何在顶点数组中布局的指令。接下来是顶点着色器代码:

```glsl
void main () {
    vec4 worldPosition = uModel * position ;
    vPos = worldPosition . xyz ;
    vNormal = ( uModel * normal ). xyz ;
    gl_Position = viewProj * worldPosition ;
}
```

这些是顶点着色器的常见操作。着色器将表面位置和法线转换为世界空间，并将它们传递给像素着色器用于着色。最后将表面位置转换为裁剪空间并传递到gl_Position, gl_Position是光栅化器使用的一个特殊的系统定义变量。gl_Position变量是任何顶点着色器所需的输出。

注意，法向量在顶点着色器中没有标准化。它们不需要标准化，因为在原始网格数据中它们的长度为1，并且这个应用程序不执行任何操作，例如顶点混合或不均匀缩放，这些操作可能不均匀地改变它们的长度。模型矩阵可以有一个统一的尺度因子，但这会按比例改变所有法线的长度，从而不会导致图5.10右侧所示的问题。

应用程序使用WebGL API进行各种渲染和着色器设置。每个可编程着色器阶段都是单独设置的，然后它们都绑定到一个程序对象。这是像素着色器设置代码：

```glsl
var fSource = document . getElementById (" fragment "). text . trim ();
var maxLights = 10;
fSource = fSource . replace (/ MAXLIGHTS /g, maxLights . toString ());
var fragmentShader = gl. createShader (gl. FRAGMENT_SHADER );
gl. shaderSource ( fragmentShader , fSource );
gl. compileShader ( fragmentShader );
```

注意“片段着色器(fragment Shader)”引用。这个术语由WebGL(以及它所基于的OpenGL)使用。正如本书前面提到的，虽然“像素着色器(pixel shader)”在某些方面不够精确，但它是更常见的用法，我们将在本书中遵循。在这段代码中，MAXLIGHTS字符串也被替换为适当的数值。大多数渲染框架执行类似的预编译着色器操作。

还有更多的应用程序端代码用于设置统一量、初始化顶点数组、清除和绘图。这里的目标是让你了解如何将着色器作为单独的处理器来处理，并使用它们自己的编程环境。

#### 3.3材质系统

渲染框架很少只实现一个着色器，通常需要一个专门的系统来处理应用程序使用的各种材质、着色模型和着色器。

正如在前面的章节中所解释的，着色器是为GPU的可编程着色器阶段之一编写的程序。因此，它是一个低级的图形API资源，而不是艺术家可以直接与之交互的东西。相比之下，材质(material)是表面视觉外观的一种面向艺术家的封装。材质有时也描述非视觉方面，如碰撞属性，这超出了本书的范围因此后面不做讨论。

### 4锯齿和抗锯齿

#### 4.1抽样滤波理论

#### 4.2基于屏幕的抗锯齿

### 5透明度、Alpha值和合成

#### 5.1混合

#### 5.2顺序无关的透明度

#### 5.3预乘Alpha和合成

### 6显示编码
